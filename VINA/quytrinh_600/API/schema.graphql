type Query {
  timesheets(
    orderBy: [TimesheetsOrderByOrderByClause!]
    where: TimesheetsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): TimesheetPaginator
  timesheetsAll(
    orderBy: [TimesheetsAllOrderByOrderByClause!]
    where: TimesheetsAllWhereWhereConditions
  ): [Timesheet!]!
  timesheet(id: ID): Timesheet
  getTimesheetApproveClientEmployee(
    orderBy: [GetTimesheetApproveClientEmployeeOrderByOrderByClause!]
    where: GetTimesheetApproveClientEmployeeWhereWhereConditions
    hasApproves: GetTimesheetApproveClientEmployeeHasApprovesWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): TimesheetPaginator
  getTimesheetSummary(
    client_employee_id: ID!
    log_date_from: String
    log_date_to: String
    work_schedule_group_id: ID!
  ): String
  getTimesheetEmployees(
    perPage: Int
    page: Int
    client_id: ID!
    state: String
    work_schedule_group_id: ID
    filter: String
  ): TimesheetEmployee
  getCountTimesheetEmployees(
    client_id: ID!
    work_schedule_group_id: ID!
  ): CountTimesheetEmployee
  simplifiedClientEmployees(
    orderBy: [SimplifiedClientEmployeesOrderByOrderByClause!]
    where: SimplifiedClientEmployeesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): SimplifiedClientEmployeePaginator
  clientEmployees(
    orderBy: [ClientEmployeesOrderByOrderByClause!]
    where: ClientEmployeesWhereWhereConditions
    hasAssignmentAsLeader: ClientEmployeesHasAssignmentAsLeaderWhereConditions
    hasAssignmentAsStaff: ClientEmployeesHasAssignmentAsStaffWhereConditions
    hasAssignmentAsJobboard: ClientEmployeesHasAssignmentAsJobboardWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeePaginator
  clientEmployeesWithoutPaginate(
    orderBy: [ClientEmployeesWithoutPaginateOrderByOrderByClause!]
    where: ClientEmployeesWithoutPaginateWhereWhereConditions
    hasAssignmentAsLeader: ClientEmployeesWithoutPaginateHasAssignmentAsLeaderWhereConditions
    hasAssignmentAsStaff: ClientEmployeesWithoutPaginateHasAssignmentAsStaffWhereConditions
  ): [ClientEmployee!]!
  clientEmployee(id: ID): ClientEmployee
  clientEmployeeSalaryHistories(
    client_employee_id: ID!
  ): [ClientEmployeeSalaryHistory!]
  clientEmployeeSummary(
    client_id: String
    log_date: Date
    status: String
    orderBy: [ClientEmployeeSummaryOrderByOrderByClause!]

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeSummaryPaginator
  clientEmployeeSalaryHistoriesWithPagination(
    orderBy: [ClientEmployeeSalaryHistoriesWithPaginationOrderByOrderByClause!]
    where: ClientEmployeeSalaryHistoriesWithPaginationWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeSalaryHistoryPaginator
  clientEmployeeSumSalaryByDepartmentOrPosition(
    client_id: String!
    filter_month: Int!
    filter_year: Int!
    filter_department: String
    filter_position: String
  ): [DepartmentSalarySummary!]
  clientEmployeePositionHistory(
    orderBy: [ClientEmployeePositionHistoryOrderByOrderByClause!]
    where: ClientEmployeePositionHistoryWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeePositionHistoryPaginator
  historicalSalaryStatistics(id: ID!): String
  clientEmployeeSalaries(
    client_id: ID!
    filter_position: String
    filter_department: String
    filter_month: Int
    filter_year: Int
  ): [ClientEmployeeSalary!]!
  clientEmployeeDepartments(client_id: ID!): String
  clientEmployeePositions(client_id: ID!): String
  requestClientEmployeeAccessToken(id: ID!): String
  clients(
    orderBy: [ClientsOrderByOrderByClause!]
    where: ClientsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientPaginator
  clientsNotExitPaginate(
    orderBy: [ClientsNotExitPaginateOrderByOrderByClause!]
    where: ClientsNotExitPaginateWhereWhereConditions
  ): [Client!]!
  client(id: ID, lang: String): Client
  clientsNotExitCalculationSheet(
    perpage: Int
    page: Int
    filter_month: Int
    filter_year: Int
    orderby: String
    order: String
  ): ListClients
  allClientsCount: Int!
  activeClientsCount: Int!
  inActiveClientsCount: Int!
  clientSalaryStatisticDepartments(
    id: ID!
    filter_by_month: String
    filter_by_year: String
  ): String
  clientByCode(code: String!): SimplifiedClient
  reportPayrolls(
    orderBy: [ReportPayrollsOrderByOrderByClause!]
    where: ReportPayrollsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ReportPayrollPaginator
  reportPits(
    orderBy: [ReportPitsOrderByOrderByClause!]
    where: ReportPitsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ReportPitPaginator
  reportPit(id: ID): ReportPit
  clientValidateHeadcount(
    client_id: ID!
    month: Int!
    year: Int!
    employees: [ID]
  ): Boolean
  clientValidateLimitEmployee(client_id: ID!): Boolean
  iglocalEmployees(
    orderBy: [IglocalEmployeesOrderByOrderByClause!]
    where: IglocalEmployeesWhereWhereConditions
    hasAssignment: IglocalEmployeesHasAssignmentWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): IglocalEmployeePaginator
  iglocalEmployeesNotExitPaginate(
    orderBy: [IglocalEmployeesNotExitPaginateOrderByOrderByClause!]
    where: IglocalEmployeesNotExitPaginateWhereWhereConditions
    hasAssignment: IglocalEmployeesNotExitPaginateHasAssignmentWhereConditions
  ): [IglocalEmployee!]!
  iglocalEmployee(id: ID): IglocalEmployee
  iglocalEmployeesAll(
    orderBy: [IglocalEmployeesAllOrderByOrderByClause!]
    where: IglocalEmployeesAllWhereWhereConditions
  ): [IglocalEmployee!]!
  iglocalAssignments(
    orderBy: [IglocalAssignmentsOrderByOrderByClause!]
    where: IglocalAssignmentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): IglocalAssignmentPaginator
  iglocalAssignment(id: ID): IglocalAssignment
  clientEmployeeOvertimeRequests(
    orderBy: [ClientEmployeeOvertimeRequestsOrderByOrderByClause!]
    where: ClientEmployeeOvertimeRequestsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeOvertimeRequestPaginator
  clientEmployeeOvertimeRequest(id: ID): ClientEmployeeOvertimeRequest
  clientEmployeeLeaveRequests(
    orderBy: [ClientEmployeeLeaveRequestsOrderByOrderByClause!]
    where: ClientEmployeeLeaveRequestsWhereWhereConditions
    hasApproves: ClientEmployeeLeaveRequestsHasApprovesWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeLeaveRequestPaginator
  clientEmployeeLeaveRequest(id: ID): ClientEmployeeLeaveRequest
  clientEmployeeEarlyLateRequests(
    orderBy: [ClientEmployeeEarlyLateRequestsOrderByOrderByClause!]
    where: ClientEmployeeEarlyLateRequestsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeEarlyLateRequestPaginator
  clientEmployeeEarlyLateRequest(id: ID): ClientEmployeeEarlyLateRequest
  calculationSheets(
    orderBy: [CalculationSheetsOrderByOrderByClause!]
    where: CalculationSheetsWhereWhereConditions
    hasApproves: CalculationSheetsHasApprovesWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): CalculationSheetPaginator
  calculationSheetsAll(
    orderBy: [CalculationSheetsAllOrderByOrderByClause!]
    where: CalculationSheetsAllWhereWhereConditions
  ): [CalculationSheet!]!
  calculationSheet(id: ID): CalculationSheet
  calculationSheetDisplayColumns(calculation_sheet_id: String!): String
  calculationSheetMonths(
    where: CalculationSheetMonthsWhereWhereConditions
  ): [CalculationSheetMonth!]!
  calculationSheetAccountantColumns(calculation_sheet_id: String!): String
  staticCalculationSheetByStatus(
    filter_month: Int
    filter_year: Int
    filter_client: String
  ): String
  staticCalculationSheetByClient(
    perpage: Int
    page: Int
    filter_month: Int
    filter_year: Int
    orderby: String
    order: String
  ): ExtListClients
  internalCanApproveCalculationSheet(id: ID): String
  calculationSheetFromCSV(id: ID!): String
  calculationSheetClientEmployees(
    orderBy: [CalculationSheetClientEmployeesOrderByOrderByClause!]
    where: CalculationSheetClientEmployeesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): CalculationSheetClientEmployeePaginator
  calculationSheetClientEmployee(id: ID): CalculationSheetClientEmployee
  calculationSheetTemplates(
    orderBy: [CalculationSheetTemplatesOrderByOrderByClause!]
    where: CalculationSheetTemplatesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): CalculationSheetTemplatePaginator
  allCalculationSheetTemplates(
    where: AllCalculationSheetTemplatesWhereWhereConditions
  ): [CalculationSheetTemplate!]!
  calculationSheetTemplate(id: ID): CalculationSheetTemplate
  calculationSheetVariables(
    orderBy: [CalculationSheetVariablesOrderByOrderByClause!]
    where: CalculationSheetVariablesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): CalculationSheetVariablePaginator
  calculationSheetVariable(id: ID): CalculationSheetVariable
  calculationSheetTotalPagesVariables(
    filter_calculation_sheet_id: String
    filter_client_employee_id: String
    filter_client_employee_ids: [String]
  ): Int
  calculationSheetAllVariables(
    filter_calculation_sheet_id: String
    filter_client_employee_id: String
    filter_client_employee_ids: [String]
    page: Int
  ): String
  clientCustomVariables(
    orderBy: [ClientCustomVariablesOrderByOrderByClause!]
    where: ClientCustomVariablesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientCustomVariablePaginator
  clientCustomVariable(id: ID): ClientCustomVariable
  clientCustomAllVariables(
    filter_client_id: String
    filter_scope: String
  ): [ClientCustomVariable!]!
  clientEmployeeCustomVariables(
    orderBy: [ClientEmployeeCustomVariablesOrderByOrderByClause!]
    where: ClientEmployeeCustomVariablesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeCustomVariablePaginator
  clientEmployeeCustomVariable(id: ID): ClientEmployeeCustomVariable
  users(
    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): UserPaginator
  user(id: ID): User
  me: Me
  supportTickets(
    orderBy: [SupportTicketsOrderByOrderByClause!]
    where: SupportTicketsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): SupportTicketPaginator
  supportTicket(id: ID): SupportTicket
  supportTicketComments(
    orderBy: [SupportTicketCommentsOrderByOrderByClause!]
    where: SupportTicketCommentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): SupportTicketCommentPaginator
  supportTicketComment(id: ID): SupportTicketComment
  formulas(
    orderBy: [FormulasOrderByOrderByClause!]
    where: FormulasWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): FormulaPaginator
  formula(id: ID): Formula
  workSchedules(
    work_schedule_group_id: String!
    client_id: String!
    orderBy: [WorkSchedulesOrderByOrderByClause!]
  ): [WorkSchedule!]!
  workSchedule(id: ID): WorkSchedule
  workScheduleGroups(
    orderBy: [WorkScheduleGroupsOrderByOrderByClause!]
    where: WorkScheduleGroupsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): WorkScheduleGroupPaginator
  workScheduleGroupTemplates(
    orderBy: [WorkScheduleGroupTemplatesOrderByOrderByClause!]
    where: WorkScheduleGroupTemplatesWhereWhereConditions
  ): [WorkScheduleGroupTemplate!]!
  getClientWorkflowSetting(
    client_id: String!
    orderBy: [GetClientWorkflowSettingOrderByOrderByClause!]
  ): [ClientWorkflowSetting!]!
  approves(
    where: ApprovesWhereWhereConditions
    orderBy: [ApprovesOrderByOrderByClause!]

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ApprovePaginator
  approve(id: ID): Approve
  clientAssignments(
    orderBy: [ClientAssignmentsOrderByOrderByClause!]
    where: ClientAssignmentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientAssignmentPaginator
  reviewersClientAssignments(
    staff_id: ID!
    client_id: ID!
  ): [ClientAssignment!]!
  notifications(unread: Int, limit: Int): String
  KnowledgeQuestions(
    orderBy: [KnowledgeQuestionsOrderByOrderByClause!]
    where: KnowledgeQuestionsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): KnowledgeQuestionPaginator
  KnowledgeQuestionsAll(
    orderBy: [KnowledgeQuestionsAllOrderByOrderByClause!]
    where: KnowledgeQuestionsAllWhereWhereConditions
  ): [KnowledgeQuestion!]!
  KnowledgeQuestion(id: ID): KnowledgeQuestion
  debitNotes(filterStatus: String): [DebitNote!]!
  debitNote(id: ID): DebitNote
  socialSecurityProfiles(
    orderBy: [SocialSecurityProfilesOrderByOrderByClause!]
    where: SocialSecurityProfilesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): SocialSecurityProfilePaginator
  socialSecurityProfile(id: ID): SocialSecurityProfile
  socialSecurityProfileHistory: [SocialSecurityProfileHistory]
  socialSecurityProfilePaginate(
    perPage: Int
    page: Int
    filterCode: String
    filterStatus: String
    clientID: ID!
    order: String
  ): SocialSecurityProfilePaginate
  translationPaginate(
    perPage: Int
    page: Int
    filterCode: String
    order: String
  ): TranslationPaginatePaginate
  translation(id: ID): [Translation]
  translations(locale: String): [Translation]
  calculationSheetTemplateAssignments(
    orderBy: [CalculationSheetTemplateAssignmentsOrderByOrderByClause!]
    where: CalculationSheetTemplateAssignmentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): CalculationSheetTemplateAssignmentPaginator
  YearHolidays(
    orderBy: [YearHolidaysOrderByOrderByClause!]
    where: YearHolidaysWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): YearHolidayPaginator
  YearHolidaysAll(
    orderBy: [YearHolidaysAllOrderByOrderByClause!]
    where: YearHolidaysAllWhereWhereConditions
  ): [YearHoliday!]!
  YearHoliday(id: ID): YearHoliday
  CalculationSheetExportTemplates(
    orderBy: [CalculationSheetExportTemplatesOrderByOrderByClause!]
    where: CalculationSheetExportTemplatesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): CalculationSheetExportTemplatePaginator
  CalculationSheetExportTemplatesAll(
    orderBy: [CalculationSheetExportTemplatesAllOrderByOrderByClause!]
    where: CalculationSheetExportTemplatesAllWhereWhereConditions
  ): [CalculationSheetExportTemplate!]!
  CalculationSheetExportTemplate(id: ID): CalculationSheetExportTemplate
  socialSecurityClaims(
    orderBy: [SocialSecurityClaimsOrderByOrderByClause!]
    where: SocialSecurityClaimsWhereWhereConditions
    hasApproves: SocialSecurityClaimsHasApprovesWhereConditions
    hasclientEmployee: SocialSecurityClaimsHasclientEmployeeWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): SocialSecurityClaimPaginator
  socialSecurityClaim(id: ID): SocialSecurityClaim
  approveFlowsAll(
    orderBy: [ApproveFlowsAllOrderByOrderByClause!]
    where: ApproveFlowsAllWhereWhereConditions
  ): [ApproveFlow]
  approveFlows(client_id: String!, flow_name: String!): [ApproveFlow]
  payrollAccountantExportTemplates(
    orderBy: [PayrollAccountantExportTemplatesOrderByOrderByClause!]
    where: PayrollAccountantExportTemplatesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): PayrollAccountantExportTemplatePaginator
  payrollAccountantExportTemplatesAll(
    orderBy: [PayrollAccountantExportTemplatesAllOrderByOrderByClause!]
    where: PayrollAccountantExportTemplatesAllWhereWhereConditions
  ): [PayrollAccountantExportTemplate!]!
  payrollAccountantExportTemplate(id: ID): PayrollAccountantExportTemplate
  payrollAccountantTemplates(
    orderBy: [PayrollAccountantTemplatesOrderByOrderByClause!]
    where: PayrollAccountantTemplatesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): PayrollAccountantTemplatePaginator
  payrollAccountantTemplate(id: ID): PayrollAccountantTemplate
  clientLogs(
    orderBy: [ClientLogsOrderByOrderByClause!]
    where: ClientLogsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientLogPaginator
  clientLog(id: ID): ClientLog
  viewAllClientLogs(client_id: ID!, page: Int): ListClientLogs
  clientEmployeeContracts(
    orderBy: [ClientEmployeeContractsOrderByOrderByClause!]
    where: ClientEmployeeContractsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeContractPaginator
  clientEmployeeContract(id: ID): ClientEmployeeContract
  emailTemplates(
    orderBy: [EmailTemplatesOrderByOrderByClause!]
    where: EmailTemplatesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): EmailTemplatePaginator
  emailTemplate(id: ID): EmailTemplate
  clientWifiCheckinSpots(
    orderBy: [ClientWifiCheckinSpotsOrderByOrderByClause!]
    where: ClientWifiCheckinSpotsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientWifiCheckinSpotPaginator
  clientWifiCheckinSpot(id: ID): ClientWifiCheckinSpot
  trainingSeminars(
    orderBy: [TrainingSeminarsOrderByOrderByClause!]
    where: TrainingSeminarsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): TrainingSeminarPaginator
  trainingSeminarsAll(
    orderBy: [TrainingSeminarsAllOrderByOrderByClause!]
    where: TrainingSeminarsAllWhereWhereConditions
  ): [TrainingSeminar!]!
  trainingSeminar(id: ID): TrainingSeminar
  clientAppliedDocuments(
    orderBy: [ClientAppliedDocumentsOrderByOrderByClause!]
    where: ClientAppliedDocumentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientAppliedDocumentPaginator
  clientAppliedDocument(id: ID): ClientAppliedDocument
  comments(
    orderBy: [CommentsOrderByOrderByClause!]
    where: CommentsWhereWhereConditions
  ): [Comment!]!
  getDownloadPath(id: ID!, model: String!): String
  worktimeRegisters(
    status: String
    orderBy: [WorktimeRegistersOrderByOrderByClause!]
    where: WorktimeRegistersWhereWhereConditions
    hasApproves: WorktimeRegistersHasApprovesWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): WorktimeRegisterPaginator
  worktimeRegister(id: ID): WorktimeRegister
  getWorktimeRegisterTimesheet(
    timesheet_id: ID!
    type: String!
    sub_type: String
  ): [WorktimeRegister]
  clientEmployeeTrainingSeminars(
    orderBy: [ClientEmployeeTrainingSeminarsOrderByOrderByClause!]
    where: ClientEmployeeTrainingSeminarsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeTrainingSeminarPaginator
  clientEmployeeTrainingSeminarAll(
    orderBy: [ClientEmployeeTrainingSeminarAllOrderByOrderByClause!]
    where: ClientEmployeeTrainingSeminarAllWhereWhereConditions
  ): [ClientEmployeeTrainingSeminar!]!
  clientEmployeeTrainingSeminar(id: ID): ClientEmployeeTrainingSeminar
  clientEmployeeTrainingSeminarGroupByEmployee(
    perPage: Int
    page: Int
    employees: [String]
    clientID: ID!
    order: String
  ): ClientEmployeeTrainingSeminarPaginate
  contracts(
    orderBy: [ContractsOrderByOrderByClause!]
    where: ContractsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ContractPaginator
  contract(id: ID): Contract
  contractTemplates(
    orderBy: [ContractTemplatesOrderByOrderByClause!]
    where: ContractTemplatesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ContractTemplatePaginator
  contractTemplate(id: ID): ContractTemplate
  contractTemplatesAll(
    orderBy: [ContractTemplatesAllOrderByOrderByClause!]
    where: ContractTemplatesAllWhereWhereConditions
  ): [ContractTemplate!]!
  jobboardSettings(
    orderBy: [JobboardSettingsOrderByOrderByClause!]
    where: JobboardSettingsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): JobboardSettingPaginator
  jobboardSetting(id: ID): JobboardSetting
  jobboardSettingByDomain(domain_mapping: String!): JobboardSetting
  ClientDepartments(
    orderBy: [ClientDepartmentsOrderByOrderByClause!]
    where: ClientDepartmentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientDepartmentPaginator
  ClientDepartmentsAll(
    where: ClientDepartmentsAllWhereWhereConditions
  ): [ClientDepartment!]!
  ClientDepartment(id: ID): ClientDepartment
  allowances(
    orderBy: [AllowancesOrderByOrderByClause!]
    where: AllowancesWhereWhereConditions
  ): [Allowance!]!
  allowance(id: ID): Allowance
  allowanceGroups(
    orderBy: [AllowanceGroupsOrderByOrderByClause!]
    where: AllowanceGroupsWhereWhereConditions
  ): [AllowanceGroup!]!
  allowanceGroup(id: ID): AllowanceGroup
  setting(key: String): String!
  jobboardJobs(
    orderBy: [JobboardJobsOrderByOrderByClause!]
    where: JobboardJobsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): JobboardJobPaginator
  jobboardJob(id: ID): JobboardJob
  jobboardApplications(
    orderBy: [JobboardApplicationsOrderByOrderByClause!]
    where: JobboardApplicationsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): JobboardApplicationPaginator
  jobboardApplication(id: ID): JobboardApplication
  evaluationGroups(
    orderBy: [EvaluationGroupsOrderByOrderByClause!]
    where: EvaluationGroupsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): EvaluationGroupPaginator
  evaluationGroup(id: ID): EvaluationGroup
  evaluations(
    orderBy: [EvaluationsOrderByOrderByClause!]
    where: EvaluationsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): EvaluationPaginator
  allEvaluations(where: AllEvaluationsWhereWhereConditions): [Evaluation!]!
  evaluation(id: ID): Evaluation
  evaluationUsers(
    where: EvaluationUsersWhereWhereConditions
  ): [EvaluationUser!]!
  evaluationUser(id: ID): EvaluationUser
  clientCameraCheckinDevices(
    orderBy: [ClientCameraCheckinDevicesOrderByOrderByClause!]
    where: ClientCameraCheckinDevicesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientCameraCheckinDevicePaginator
  clientCameraCheckinDevice(id: ID): ClientCameraCheckinDevice
  hanetSettings(where: HanetSettingsWhereWhereConditions): [HanetSetting!]!
  hanetSetting(id: ID): HanetSetting
  hanetDevices(
    orderBy: [HanetDevicesOrderByOrderByClause!]
    where: HanetDevicesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): HanetDevicePaginator
  hanetDevice(id: ID): HanetDevice
  hanetPlaces(
    orderBy: [HanetPlacesOrderByOrderByClause!]
    where: HanetPlacesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): HanetPlacePaginator
  allHanetPlaces(
    orderBy: [AllHanetPlacesOrderByOrderByClause!]
    where: AllHanetPlacesWhereWhereConditions
  ): [HanetPlace!]!
  hanetPlace(id: ID): HanetPlace
  clientEmployeeDependents(
    where: ClientEmployeeDependentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientEmployeeDependentPaginator
  clientEmployeeDependent(id: ID): ClientEmployeeDependent
  clientDepartmentEmployees(
    orderBy: [ClientDepartmentEmployeesOrderByOrderByClause!]
    where: ClientDepartmentEmployeesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientDepartmentEmployeePaginator
  workTimeRegisterPeriods(
    orderBy: [WorkTimeRegisterPeriodsOrderByOrderByClause!]
    where: WorkTimeRegisterPeriodsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): WorkTimeRegisterPeriodPaginator
  workTimeRegisterPeriod(id: ID): WorkTimeRegisterPeriod
  clientProjects(
    orderBy: [ClientProjectsOrderByOrderByClause!]
    where: ClientProjectsWhereWhereConditions
    hasClientProjectEmployee: ClientProjectsHasClientProjectEmployeeWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientProjectPaginator
  clientProjectsNotPaginate(
    orderBy: [ClientProjectsNotPaginateOrderByOrderByClause!]
    where: ClientProjectsNotPaginateWhereWhereConditions
    hasClientProjectEmployee: ClientProjectsNotPaginateHasClientProjectEmployeeWhereConditions
  ): [ClientProject!]!
  clientProject(id: ID): ClientProject
  clientProjectEmployees(
    orderBy: [ClientProjectEmployeesOrderByOrderByClause!]
    where: ClientProjectEmployeesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientProjectEmployeePaginator
  clientProjectEmployee(id: ID): ClientProjectEmployee
  clientProjectTimelogs(
    orderBy: [ClientProjectTimelogsOrderByOrderByClause!]
    where: ClientProjectTimelogsWhereWhereConditions
    hasclientEmployee: ClientProjectTimelogsHasclientEmployeeWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ClientProjectTimelogPaginator
  clientProjectTimelog(id: ID): ClientProjectTimelog
  mobile_tiles(orderBy: [MobileTilesOrderByOrderByClause!]): [MobileTile]
  mobile_tile(id: ID): MobileTile
  jobboardAssignments(
    orderBy: [JobboardAssignmentsOrderByOrderByClause!]
    where: JobboardAssignmentsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): JobboardAssignmentPaginator
  paymentRequests(
    where: PaymentRequestsWhereWhereConditions
    orderBy: [PaymentRequestsOrderByOrderByClause!]

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): PaymentRequestPaginator
  paymentRequest(id: ID): PaymentRequest
  paidLeaveChanges(
    orderBy: [PaidLeaveChangesOrderByOrderByClause!]
    where: PaidLeaveChangesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): PayrollAccountantExportTemplatePaginator
  paidLeaveChangesAll(
    orderBy: [PaidLeaveChangesAllOrderByOrderByClause!]
    where: PaidLeaveChangesAllWhereWhereConditions
  ): [PaidLeaveChange!]!
  paidLeaveChange(id: ID): PaidLeaveChange
  socialSecurityClaimTrackings(
    orderBy: [SocialSecurityClaimTrackingsOrderByOrderByClause!]
    where: SocialSecurityClaimTrackingsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): SocialSecurityClaimTrackingPaginator
  socialSecurityClaimTrackingsAll(
    orderBy: [SocialSecurityClaimTrackingsAllOrderByOrderByClause!]
    where: SocialSecurityClaimTrackingsAllWhereWhereConditions
  ): [SocialSecurityClaimTracking]
  socialSecurityClaimTracking(id: ID): SocialSecurityClaimTracking
  assignmentProjects(
    orderBy: [AssignmentProjectsOrderByOrderByClause!]
    where: AssignmentProjectsWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): AssignmentProjectPaginator
  assignmentProject(id: ID): AssignmentProject
  assignmentTasks(
    orderBy: [AssignmentTasksOrderByOrderByClause!]
    where: AssignmentTasksWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): AssignmentTaskPaginator
  assignmentTasksAll(
    orderBy: [AssignmentTasksAllOrderByOrderByClause!]
    where: AssignmentTasksAllWhereWhereConditions
  ): [AssignmentTask!]!
  assignmentTask(id: ID): AssignmentTask
  assignmentProjectUsers(
    keywords: String
    orderBy: [AssignmentProjectUsersOrderByOrderByClause!]
    where: AssignmentProjectUsersWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): AssignmentProjectUserPaginator
  assignmentProjectUser(id: ID): AssignmentProjectUser
  unassignedProjectUsers(
    projectId: String

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): ProjectUserPaginator
  appliedDocumentCategories(
    orderBy: [AppliedDocumentCategoriesOrderByOrderByClause!]
    where: AppliedDocumentCategoriesWhereWhereConditions

    # Limits number of fetched elements.
    first: Int!

    # The offset from which elements are returned.
    page: Int
  ): AppliedDocumentCategoryPaginator
  listAppliedDocumentCategory(
    orderBy: [ListAppliedDocumentCategoryOrderByOrderByClause!]
  ): [AppliedDocumentCategory!]!
  appliedDocumentCategory(id: ID): AppliedDocumentCategory
}

# Order by clause for the `orderBy` argument on the query `timesheets`.
input TimesheetsOrderByOrderByClause {
  # The column that is used for ordering.
  field: TimesheetsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `timesheets`.
enum TimesheetsOrderByColumn {
  CLIENT_EMPLOYEE_ID
  LOG_DATE
  ACTIVITY
  CHECK_IN
  CHECK_OUT
  LEAVE_TYPE
  ATTENTDANT_STATUS
  WORK_STATUS
  CREATED_AT
  UPDATED_AT
}

# The available directions for ordering a list of records.
enum SortOrder {
  # Sort records in ascending order.
  ASC

  # Sort records in descending order.
  DESC
}

# Dynamic WHERE conditions for the `where` argument on the query `timesheets`.
input TimesheetsWhereWhereConditions {
  # The column that is used for the condition.
  column: TimesheetsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [TimesheetsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [TimesheetsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `timesheets`.
enum TimesheetsWhereColumn {
  CLIENT_EMPLOYEE_ID
  LOG_DATE
  ACTIVITY
  CHECK_IN
  CHECK_OUT
  LEAVE_TYPE
  ATTENTDANT_STATUS
  WORK_STATUS
  ID
  CREATED_AT
  UPDATED_AT
}

# The available SQL operators that are used to filter query results.
enum SQLOperator {
  # Equal operator (`=`)
  EQ

  # Not equal operator (`!=`)
  NEQ

  # Greater than operator (`>`)
  GT

  # Greater than or equal operator (`>=`)
  GTE

  # Less than operator (`<`)
  LT

  # Less than or equal operator (`<=`)
  LTE

  # Simple pattern matching (`LIKE`)
  LIKE

  # Negation of simple pattern matching (`NOT LIKE`)
  NOT_LIKE

  # Whether a value is within a set of values (`IN`)
  IN

  # Whether a value is not within a set of values (`NOT IN`)
  NOT_IN

  # Whether a value is within a range of values (`BETWEEN`)
  BETWEEN

  # Whether a value is not within a range of values (`NOT BETWEEN`)
  NOT_BETWEEN

  # Whether a value is null (`IS NULL`)
  IS_NULL

  # Whether a value is not null (`IS NOT NULL`)
  IS_NOT_NULL
}

# Loose type that allows any value. Be careful when passing in large `Int` or `Float` literals,
# as they may not be parsed correctly on the server side. Use `String` literals if you are
# dealing with really large numbers to be on the safe side.
scalar Mixed

# A paginated list of Timesheet items.
type TimesheetPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Timesheet items.
  data: [Timesheet!]!
}

# Pagination information about the corresponding list of items.
type PaginatorInfo {
  # Total count of available items in the page.
  count: Int!

  # Current pagination page.
  currentPage: Int!

  # Index of first item in the current page.
  firstItem: Int

  # If collection has more pages.
  hasMorePages: Boolean!

  # Index of last item in the current page.
  lastItem: Int

  # Last page number of the collection.
  lastPage: Int!

  # Number of items per page in the collection.
  perPage: Int!

  # Total items available in the collection.
  total: Int!
}

type Timesheet {
  id: ID!
  client_employee_id: String
  log_date: Date
  activity: String
  work_place: String
  working_hours: Float
  rest_hours: Float
  overtime_hours: Float
  check_in: String
  check_out: String
  leave_type: String!
  attentdant_status: String
  work_status: String
  state: String
  reason: String
  approved_date: DateTime
  note: String
  paid_leave_hours: Float
  created_at: DateTime!
  updated_at: DateTime!
}

# A date string with format `Y-m-d`, e.g. `2011-05-23`.
scalar Date

# A datetime string with format `Y-m-d H:i:s`, e.g. `2018-01-01 13:00:00`.
scalar DateTime

# Order by clause for the `orderBy` argument on the query `timesheetsAll`.
input TimesheetsAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: TimesheetsAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `timesheetsAll`.
enum TimesheetsAllOrderByColumn {
  CLIENT_EMPLOYEE_ID
  LOG_DATE
  ACTIVITY
  CHECK_IN
  CHECK_OUT
  LEAVE_TYPE
  ATTENTDANT_STATUS
  WORK_STATUS
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `timesheetsAll`.
input TimesheetsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: TimesheetsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [TimesheetsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [TimesheetsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `timesheetsAll`.
enum TimesheetsAllWhereColumn {
  CLIENT_EMPLOYEE_ID
  LOG_DATE
  ACTIVITY
  CHECK_IN
  CHECK_OUT
  LEAVE_TYPE
  ATTENTDANT_STATUS
  WORK_STATUS
  ID
  STATE
  CREATED_AT
  UPDATED_AT
}

# Order by clause for the `orderBy` argument on the query `getTimesheetApproveClientEmployee`.
input GetTimesheetApproveClientEmployeeOrderByOrderByClause {
  # The column that is used for ordering.
  field: GetTimesheetApproveClientEmployeeOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `getTimesheetApproveClientEmployee`.
enum GetTimesheetApproveClientEmployeeOrderByColumn {
  CLIENT_EMPLOYEE_ID
  CHECK_IN
  CHECK_OUT
  LOG_DATE
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `getTimesheetApproveClientEmployee`.
input GetTimesheetApproveClientEmployeeWhereWhereConditions {
  # The column that is used for the condition.
  column: GetTimesheetApproveClientEmployeeWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [GetTimesheetApproveClientEmployeeWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [GetTimesheetApproveClientEmployeeWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `getTimesheetApproveClientEmployee`.
enum GetTimesheetApproveClientEmployeeWhereColumn {
  ID
  CLIENT_EMPLOYEE_ID
  LOG_DATE
}

# Dynamic WHERE conditions for the `hasApproves` argument on the query `getTimesheetApproveClientEmployee`.
input GetTimesheetApproveClientEmployeeHasApprovesWhereConditions {
  # The column that is used for the condition.
  column: GetTimesheetApproveClientEmployeeHasApprovesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [GetTimesheetApproveClientEmployeeHasApprovesWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [GetTimesheetApproveClientEmployeeHasApprovesWhereConditions!]
}

# Allowed column names for the `hasApproves` argument on the query `getTimesheetApproveClientEmployee`.
enum GetTimesheetApproveClientEmployeeHasApprovesColumn {
  CREATOR_ID
  ASSIGNEE_ID
}

type TimesheetEmployee {
  data: [TimesheetEmployeeItem]
  pagination: CustomPagination
}

type TimesheetEmployeeItem {
  id: ID!
  client_id: String
  full_name: String
  code: String
  role: String
  department: String
  position: String
  title: String
  approve_id: ID
  work_schedule_group_template_id: String
}

type CustomPagination {
  total: Int
  count: Int
  per_page: Int
  current_page: Int
  total_pages: Int
}

type CountTimesheetEmployee {
  total: Int!
  totalNew: Int!
  totalProcessing: Int!
  totalApproved: Int!
}

# Order by clause for the `orderBy` argument on the query `simplifiedClientEmployees`.
input SimplifiedClientEmployeesOrderByOrderByClause {
  # The column that is used for ordering.
  field: SimplifiedClientEmployeesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `simplifiedClientEmployees`.
enum SimplifiedClientEmployeesOrderByColumn {
  FULL_NAME
  CONTACT_PHONE_NUMBER
  DEPARTMENT
  ROLE
  CODE
  TITLE
}

# Dynamic WHERE conditions for the `where` argument on the query `simplifiedClientEmployees`.
input SimplifiedClientEmployeesWhereWhereConditions {
  # The column that is used for the condition.
  column: SimplifiedClientEmployeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SimplifiedClientEmployeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SimplifiedClientEmployeesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `simplifiedClientEmployees`.
enum SimplifiedClientEmployeesWhereColumn {
  TITLE
  POSITION
  CLIENT_ID
  FULL_NAME
  CONTACT_PHONE_NUMBER
  DEPARTMENT
  STATUS
  CODE
  ID
  ROLE
  WORK_SCHEDULE_GROUP_TEMPLATE_ID
  USER_ID
}

# A paginated list of SimplifiedClientEmployee items.
type SimplifiedClientEmployeePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of SimplifiedClientEmployee items.
  data: [SimplifiedClientEmployee!]!
}

type SimplifiedClientEmployee {
  id: ID!
  client_id: ID!
  full_name: String
  code: String
  user_id: String
}

# Order by clause for the `orderBy` argument on the query `clientEmployees`.
input ClientEmployeesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployees`.
enum ClientEmployeesOrderByColumn {
  FULL_NAME
  CONTACT_PHONE_NUMBER
  DEPARTMENT
  ROLE
  CODE
  TITLE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployees`.
input ClientEmployeesWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployees`.
enum ClientEmployeesWhereColumn {
  TITLE
  POSITION
  CLIENT_ID
  FULL_NAME
  CONTACT_PHONE_NUMBER
  DEPARTMENT
  STATUS
  CODE
  ID
  ROLE
  WORK_SCHEDULE_GROUP_TEMPLATE_ID
  USER_ID
}

# Dynamic WHERE conditions for the `hasAssignmentAsLeader` argument on the query `clientEmployees`.
input ClientEmployeesHasAssignmentAsLeaderWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesHasAssignmentAsLeaderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesHasAssignmentAsLeaderWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesHasAssignmentAsLeaderWhereConditions!]
}

# Allowed column names for the `hasAssignmentAsLeader` argument on the query `clientEmployees`.
enum ClientEmployeesHasAssignmentAsLeaderColumn {
  STAFF_ID
}

# Dynamic WHERE conditions for the `hasAssignmentAsStaff` argument on the query `clientEmployees`.
input ClientEmployeesHasAssignmentAsStaffWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesHasAssignmentAsStaffColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesHasAssignmentAsStaffWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesHasAssignmentAsStaffWhereConditions!]
}

# Allowed column names for the `hasAssignmentAsStaff` argument on the query `clientEmployees`.
enum ClientEmployeesHasAssignmentAsStaffColumn {
  LEADER_ID
}

# Dynamic WHERE conditions for the `hasAssignmentAsJobboard` argument on the query `clientEmployees`.
input ClientEmployeesHasAssignmentAsJobboardWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesHasAssignmentAsJobboardColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesHasAssignmentAsJobboardWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesHasAssignmentAsJobboardWhereConditions!]
}

# Allowed column names for the `hasAssignmentAsJobboard` argument on the query `clientEmployees`.
enum ClientEmployeesHasAssignmentAsJobboardColumn {
  JOBBOARD_JOB_ID
}

# A paginated list of ClientEmployee items.
type ClientEmployeePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployee items.
  data: [ClientEmployee!]!
}

type ClientEmployee {
  id: ID!
  client_id: String
  full_name: String
  code: String
  probation_start_date: Date
  probation_end_date: Date
  official_contract_signing_date: Date
  type_of_employment_contract: String
  salary: String
  allowance_for_responsibilities: String
  fixed_allowance: String
  is_tax_applicable: Boolean
  is_insurance_applicable: Boolean
  number_of_dependents: Int
  bank_account: String
  bank_account_number: String
  bank_name: String
  bank_branch: String
  social_insurance_number: String
  date_of_birth: String
  sex: String
  department: String
  position: String
  title: String
  workplace: String
  marital_status: String
  salary_for_social_insurance_payment: String
  effective_date_of_social_insurance: Date
  medical_care_hospital_name: String
  medical_care_hospital_code: String
  nationality: String
  nation: String
  id_card_number: String
  is_card_issue_date: Date
  id_card_issue_place: String
  birth_place_address: String
  birth_place_street: String
  birth_place_wards: String
  birth_place_district: String
  birth_place_city_province: String
  resident_address: String
  resident_street: String
  resident_wards: String
  resident_district: String
  resident_city_province: String
  contact_address: String
  contact_street: String
  contact_wards: String
  contact_district: String
  contact_city_province: String
  contact_phone_number: String
  contract_no: String
  household_head_info: String
  household_code: String
  household_head_fullname: String
  household_head_id_card_number: String
  household_head_relation: String
  household_head_phone: String
  resident_record_number: String
  resident_record_type: String
  resident_village: String
  resident_commune_ward_district_province: String
  foreigner_job_position: String
  foreigner_contract_status: String
  education_level: String
  status: String
  quitted_at: Date
  user_id: String
  role: String
  deleted_at: DateTime
  created_at: DateTime
  updated_at: DateTime
  work_schedule_group_template_id: String
  assignmentsAsStaff: [ClientAssignment]!
  assignmentsAsLeader: [ClientAssignment]!
  leaders: [ClientEmployee]!
  contracts: [ClientEmployeeContract]
  year_paid_leave_count: Float
  avatar_path: String
  avatar_path_large: String
  currency: String
  mst_code: String
  career: String
  media: [Media]
  user: UserDisplay
  hanetPerson: HanetPerson
  hour_wage: String
}

type ClientAssignment {
  id: ID!
  leader: ClientEmployee!
  staff: ClientEmployee!
  client: Client!
  client_id: String!
  leader_id: String!
  staff_id: String!
  created_at: DateTime
  updated_at: DateTime
}

type Client {
  id: ID!
  code: String
  company_name: String
  address: String
  address_province: String
  address_city: String
  company_bank_account: String
  company_account_number: String
  company_bank_name: String
  company_bank_branch: String
  person_signing_a_bank_document: String
  employees_number_foreign: Int
  employees_number_vietnamese: Int
  rewards_for_achievements: String
  annual_salary_bonus: String
  social_insurance_and_health_insurance_ceiling: String
  unemployment_insurance_ceiling: String
  payroll_creator: String
  payroll_approver: String
  social_insurance_agency: String
  social_insurance_account_name: String
  social_insurance_account_number: String
  social_insurance_bank_name: String
  social_insurance_bank_branch: String
  social_insurance_unit_code: String
  trade_union_agency: String
  trade_union_account_name: String
  trade_union_account_number: String
  trade_union_bank_name: String
  trade_union_bank_branch: String
  presenter_phone: String
  company_contact_fax: String
  presenter_email: String
  presenter_name: String
  company_license_no: String
  company_license_issuer: String
  company_license_issued_at: Date
  company_license_updated_at: Date
  company_license_at: String
  company_name_translations: JSON
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime!
  timesheet_min_time_block: Int
  company_contact_phone: String
  company_contact_email: String
  day_payroll_start: Int
  day_payroll_end: Int
  type_of_business: String
  is_active: Boolean
  assignedInternalEmployees: [IglocalEmployee]!
  clientWorkflowSetting: ClientWorkflowSetting
  standard_work_hours_per_day: Float
}

# Can be used as an argument to upload files using https://github.com/jaydenseric/graphql-multipart-request-spec
scalar JSON

type IglocalEmployee {
  id: ID!
  user_id: String!
  user: User
  code: String!
  name: String!
  role: String!
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
  assignments: [IglocalAssignment]
}

type User {
  id: ID!
  client_id: String!
  username: String!
  name: String!
  code: String
  email: String!
  changed_random_password: Int!
  client: Client
  clientEmployee: SimplifiedClientEmployee
  iGlocalEmployee: IglocalEmployee
  assignedApproves: [Approve]
  assigned_approves_count: Int!
  permissions: String
  created_at: DateTime!
  updated_at: DateTime!
  prefered_language: String
  selfEvaluation: Boolean
  otherEvaluation: Boolean
  is_internal: Int
  timezone_name: String
  is_email_notification: Boolean
  is_active: Boolean
}

type Approve {
  id: String
  type: String
  content: String
  creator_id: String
  original_creator_id: String
  assignee_id: String
  created_at: DateTime
  approved_at: DateTime
  declined_at: DateTime
  step: Int
  target_type: String
  target_id: String
  target: ApproveTarget
  targetCalculationSheet: CalculationSheet
  targetWorktimeRegister: WorktimeRegister
  creator: User
  assignee: User
  original_creator: User
  is_final_step: Boolean
  approved_comment: String
  approve_group_id: String
}

union ApproveTarget = ClientEmployeeLeaveRequest

type ClientEmployeeLeaveRequest {
  id: ID!
  client_employee_id: String!
  clientEmployee: ClientEmployee
  start_time: DateTime
  end_time: DateTime
  duration: Float!
  half_day: String!
  type_of_leave: String!
  reason: String
  status: String!
  approved_by: String
  approved_date: DateTime
  approved_comment: String
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

type CalculationSheet {
  id: ID!
  client: Client!
  name: String!
  fomulas: String!
  payment_period: String!
  display_columns: String
  payslip_columns_setting: String
  payslip_accountant_columns_setting: String
  payslip_html_template_en: String
  payslip_html_template_vi: String
  payslip_html_template_ja: String
  is_multilingual: Boolean
  payslip_html_template: String
  template_export_id: String
  month: Int!
  year: Int!
  date_to: String!
  date_from: String!
  status: String
  created_at: DateTime!
  updated_at: DateTime!
  calculation_sheet_template_id: String
  approves: [Approve]
  approved_comment: String
  payslip_date: Date
}

type WorktimeRegister {
  id: ID!
  client_employee_id: String!
  clientEmployee: ClientEmployee
  start_time: DateTime
  end_time: DateTime
  code: String!
  type: String!
  sub_type: String
  reason: String
  status: String!
  approved_by: String
  approved_date: DateTime
  approved_comment: String
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
  workTimeRegisterPeriod: [WorkTimeRegisterPeriod!]!
  registered_hours: Float
}

type WorkTimeRegisterPeriod {
  id: ID!
  worktime_register_id: String!
  date_time_register: Date!
  type_register: Boolean
  start_time: String
  end_time: String
  created_at: DateTime
  updated_at: DateTime
  worktimeRegister: WorktimeRegister
}

type IglocalAssignment {
  id: ID!
  iglocalEmployee: IglocalEmployee!
  client: Client
  client_id: String!
  created_at: DateTime!
  updated_at: DateTime!
}

type ClientWorkflowSetting {
  id: String
  client_id: String
  enable_overtime_request: Boolean
  enable_leave_request: Boolean
  enable_early_leave_request: Boolean
  enable_timesheet_input: Boolean
  enable_timesheet_rule: Boolean
  enable_social_security_manage: Boolean
  enable_salary_payment: Boolean
  show_timesheet_for_customer: Boolean
  manage_user: String
  enable_wifi_checkin: Boolean
  enable_training_seminar: Boolean
  enable_recruit_function: Boolean
  enable_contract_reminder: Boolean
  enable_create_payroll: Boolean
  enable_setting_flow_permission: Boolean
  client_employee_limit: Int
}

type ClientEmployeeContract {
  id: ID!
  client_employee_id: String!
  contract_type: String
  contract_code: String
  contract_signing_date: String
  contract_end_date: String
  created_at: DateTime
  updated_at: DateTime
  mediaTemp: [MediaTemp]
  media_path: String
}

type MediaTemp {
  id: ID!
  name: String
  file_name: String
  collection_name: String
  mime_type: String
  created_at: String
  url: String
}

type Media {
  id: ID!
  name: String
  file_name: String
  collection_name: String
  mime_type: String
  created_at: String
}

type UserDisplay {
  client_id: String
  name: String
  email: String
  prefered_language: String
}

type HanetPerson {
  id: ID!
  client_id: String!
  avatar: String
  hanetPlaces: [HanetPlace]
}

type HanetPlace {
  id: ID!
  client_id: String!
  name: String!
  address: String
  hanet_place_id: Int
  created_at: DateTime!
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `clientEmployeesWithoutPaginate`.
input ClientEmployeesWithoutPaginateOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeesWithoutPaginateOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeesWithoutPaginate`.
enum ClientEmployeesWithoutPaginateOrderByColumn {
  FULL_NAME
  CONTACT_PHONE_NUMBER
  DEPARTMENT
  ROLE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeesWithoutPaginate`.
input ClientEmployeesWithoutPaginateWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesWithoutPaginateWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesWithoutPaginateWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesWithoutPaginateWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeesWithoutPaginate`.
enum ClientEmployeesWithoutPaginateWhereColumn {
  CLIENT_ID
  FULL_NAME
  CONTACT_PHONE_NUMBER
  DEPARTMENT
  POSITION
  TITLE
  STATUS
  CODE
  ID
  ROLE
  WORK_SCHEDULE_GROUP_TEMPLATE_ID
  USER_ID
}

# Dynamic WHERE conditions for the `hasAssignmentAsLeader` argument on the query `clientEmployeesWithoutPaginate`.
input ClientEmployeesWithoutPaginateHasAssignmentAsLeaderWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesWithoutPaginateHasAssignmentAsLeaderColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesWithoutPaginateHasAssignmentAsLeaderWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesWithoutPaginateHasAssignmentAsLeaderWhereConditions!]
}

# Allowed column names for the `hasAssignmentAsLeader` argument on the query `clientEmployeesWithoutPaginate`.
enum ClientEmployeesWithoutPaginateHasAssignmentAsLeaderColumn {
  STAFF_ID
}

# Dynamic WHERE conditions for the `hasAssignmentAsStaff` argument on the query `clientEmployeesWithoutPaginate`.
input ClientEmployeesWithoutPaginateHasAssignmentAsStaffWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeesWithoutPaginateHasAssignmentAsStaffColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeesWithoutPaginateHasAssignmentAsStaffWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeesWithoutPaginateHasAssignmentAsStaffWhereConditions!]
}

# Allowed column names for the `hasAssignmentAsStaff` argument on the query `clientEmployeesWithoutPaginate`.
enum ClientEmployeesWithoutPaginateHasAssignmentAsStaffColumn {
  LEADER_ID
}

type ClientEmployeeSalaryHistory {
  id: ID!
  client_employee_id: String!
  created_at: DateTime!
  old_salary: String
  new_salary: String
  old_annual_salary_bonus: String
  new_annual_salary_bonus: String
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeSummary`.
input ClientEmployeeSummaryOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeSummaryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeSummary`.
enum ClientEmployeeSummaryOrderByColumn {
  FULL_NAME
  WORK_STATUS
}

# A paginated list of ClientEmployeeSummary items.
type ClientEmployeeSummaryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeSummary items.
  data: [ClientEmployeeSummary!]!
}

type ClientEmployeeSummary {
  id: ID
  period_id: String
  full_name: String
  date_time_register: Date
  start_time: String
  end_time: String
  duration: Float
  period_start_time: String
  period_end_time: String
  type_register: Int
  sub_type: String
  reason: String
  standard_work_hours_per_day: Float
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeSalaryHistoriesWithPagination`.
input ClientEmployeeSalaryHistoriesWithPaginationOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeSalaryHistoriesWithPaginationOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeSalaryHistoriesWithPagination`.
enum ClientEmployeeSalaryHistoriesWithPaginationOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeSalaryHistoriesWithPagination`.
input ClientEmployeeSalaryHistoriesWithPaginationWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeSalaryHistoriesWithPaginationWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeSalaryHistoriesWithPaginationWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeSalaryHistoriesWithPaginationWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeSalaryHistoriesWithPagination`.
enum ClientEmployeeSalaryHistoriesWithPaginationWhereColumn {
  CLIENT_EMPLOYEE_ID
}

# A paginated list of ClientEmployeeSalaryHistory items.
type ClientEmployeeSalaryHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeSalaryHistory items.
  data: [ClientEmployeeSalaryHistory!]!
}

type DepartmentSalarySummary {
  department: String
  position: String
  salary: String
}

# Order by clause for the `orderBy` argument on the query `clientEmployeePositionHistory`.
input ClientEmployeePositionHistoryOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeePositionHistoryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeePositionHistory`.
enum ClientEmployeePositionHistoryOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeePositionHistory`.
input ClientEmployeePositionHistoryWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeePositionHistoryWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeePositionHistoryWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeePositionHistoryWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeePositionHistory`.
enum ClientEmployeePositionHistoryWhereColumn {
  CLIENT_EMPLOYEE_ID
}

# A paginated list of ClientEmployeePositionHistory items.
type ClientEmployeePositionHistoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeePositionHistory items.
  data: [ClientEmployeePositionHistory!]!
}

type ClientEmployeePositionHistory {
  id: ID!
  client_employee_id: String!
  created_at: DateTime!
  old_department: String
  old_position: String
  new_department: String
  new_position: String
}

type ClientEmployeeSalary {
  id: ID!
  client_employee_id: String!
  created_at: DateTime!
  position: String!
  department: String!
  salary: Float
  clientEmployee: ClientEmployee
}

# Order by clause for the `orderBy` argument on the query `clients`.
input ClientsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clients`.
enum ClientsOrderByColumn {
  COMPANY_NAME
  ADDRESS
  CREATED_AT
  CODE
}

# Dynamic WHERE conditions for the `where` argument on the query `clients`.
input ClientsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clients`.
enum ClientsWhereColumn {
  CODE
  COMPANY_NAME
  DAY_PAYROLL_START
  DAY_PAYROLL_END
}

# A paginated list of Client items.
type ClientPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Client items.
  data: [Client!]!
}

# Order by clause for the `orderBy` argument on the query `clientsNotExitPaginate`.
input ClientsNotExitPaginateOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientsNotExitPaginateOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientsNotExitPaginate`.
enum ClientsNotExitPaginateOrderByColumn {
  COMPANY_NAME
  ADDRESS
  CREATED_AT
  CODE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientsNotExitPaginate`.
input ClientsNotExitPaginateWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientsNotExitPaginateWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientsNotExitPaginateWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientsNotExitPaginateWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientsNotExitPaginate`.
enum ClientsNotExitPaginateWhereColumn {
  CODE
  COMPANY_NAME
  DAY_PAYROLL_START
  DAY_PAYROLL_END
}

type ListClients {
  data: [Client]
  pagination: CustomPagination
}

type SimplifiedClient {
  id: ID!
  code: String
  company_name: String
  address: String
}

# Order by clause for the `orderBy` argument on the query `reportPayrolls`.
input ReportPayrollsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ReportPayrollsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `reportPayrolls`.
enum ReportPayrollsOrderByColumn {
  STATUS
  DATE_FROM
  DATE_TO
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `reportPayrolls`.
input ReportPayrollsWhereWhereConditions {
  # The column that is used for the condition.
  column: ReportPayrollsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ReportPayrollsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ReportPayrollsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `reportPayrolls`.
enum ReportPayrollsWhereColumn {
  ID
  DATE_FROM
  DATE_TO
  CREATED_AT
}

# A paginated list of ReportPayroll items.
type ReportPayrollPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ReportPayroll items.
  data: [ReportPayroll!]!
}

type ReportPayroll {
  id: ID!
  date_from: String
  date_to: String
  status: String
  created_at: DateTime!
  updated_at: DateTime!
  path: String
}

# Order by clause for the `orderBy` argument on the query `reportPits`.
input ReportPitsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ReportPitsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `reportPits`.
enum ReportPitsOrderByColumn {
  STATUS
  NAME
  DATE_FROM_TO
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `reportPits`.
input ReportPitsWhereWhereConditions {
  # The column that is used for the condition.
  column: ReportPitsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ReportPitsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ReportPitsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `reportPits`.
enum ReportPitsWhereColumn {
  ID
  CLIENT_ID
  NAME
  DATE_FROM_TO
  STATUS
  CREATED_AT
}

# A paginated list of ReportPit items.
type ReportPitPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ReportPit items.
  data: [ReportPit!]!
}

type ReportPit {
  id: ID!
  name: String
  date_from_to: String
  form_data: String
  client_id: String
  status: String
  created_at: DateTime!
  updated_at: DateTime!
  path: String
}

# Order by clause for the `orderBy` argument on the query `iglocalEmployees`.
input IglocalEmployeesOrderByOrderByClause {
  # The column that is used for ordering.
  field: IglocalEmployeesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `iglocalEmployees`.
enum IglocalEmployeesOrderByColumn {
  USER_ID
  CODE
  NAME
  ROLE
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `iglocalEmployees`.
input IglocalEmployeesWhereWhereConditions {
  # The column that is used for the condition.
  column: IglocalEmployeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [IglocalEmployeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [IglocalEmployeesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `iglocalEmployees`.
enum IglocalEmployeesWhereColumn {
  ID
  USER_ID
  CODE
  NAME
  ROLE
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `hasAssignment` argument on the query `iglocalEmployees`.
input IglocalEmployeesHasAssignmentWhereConditions {
  # The column that is used for the condition.
  column: IglocalEmployeesHasAssignmentColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [IglocalEmployeesHasAssignmentWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [IglocalEmployeesHasAssignmentWhereConditions!]
}

# Allowed column names for the `hasAssignment` argument on the query `iglocalEmployees`.
enum IglocalEmployeesHasAssignmentColumn {
  CLIENT_ID
  IGLOCAL_EMPLOYEE_ID
}

# A paginated list of IglocalEmployee items.
type IglocalEmployeePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of IglocalEmployee items.
  data: [IglocalEmployee!]!
}

# Order by clause for the `orderBy` argument on the query `iglocalEmployeesNotExitPaginate`.
input IglocalEmployeesNotExitPaginateOrderByOrderByClause {
  # The column that is used for ordering.
  field: IglocalEmployeesNotExitPaginateOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `iglocalEmployeesNotExitPaginate`.
enum IglocalEmployeesNotExitPaginateOrderByColumn {
  USER_ID
  CODE
  NAME
  ROLE
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `iglocalEmployeesNotExitPaginate`.
input IglocalEmployeesNotExitPaginateWhereWhereConditions {
  # The column that is used for the condition.
  column: IglocalEmployeesNotExitPaginateWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [IglocalEmployeesNotExitPaginateWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [IglocalEmployeesNotExitPaginateWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `iglocalEmployeesNotExitPaginate`.
enum IglocalEmployeesNotExitPaginateWhereColumn {
  ID
  USER_ID
  CODE
  NAME
  ROLE
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `hasAssignment` argument on the query `iglocalEmployeesNotExitPaginate`.
input IglocalEmployeesNotExitPaginateHasAssignmentWhereConditions {
  # The column that is used for the condition.
  column: IglocalEmployeesNotExitPaginateHasAssignmentColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [IglocalEmployeesNotExitPaginateHasAssignmentWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [IglocalEmployeesNotExitPaginateHasAssignmentWhereConditions!]
}

# Allowed column names for the `hasAssignment` argument on the query `iglocalEmployeesNotExitPaginate`.
enum IglocalEmployeesNotExitPaginateHasAssignmentColumn {
  CLIENT_ID
  IGLOCAL_EMPLOYEE_ID
}

# Order by clause for the `orderBy` argument on the query `iglocalEmployeesAll`.
input IglocalEmployeesAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: IglocalEmployeesAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `iglocalEmployeesAll`.
enum IglocalEmployeesAllOrderByColumn {
  CODE
  NAME
  ROLE
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `iglocalEmployeesAll`.
input IglocalEmployeesAllWhereWhereConditions {
  # The column that is used for the condition.
  column: IglocalEmployeesAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [IglocalEmployeesAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [IglocalEmployeesAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `iglocalEmployeesAll`.
enum IglocalEmployeesAllWhereColumn {
  ID
  USER_ID
  CODE
  NAME
  ROLE
  CREATED_AT
  UPDATED_AT
}

# Order by clause for the `orderBy` argument on the query `iglocalAssignments`.
input IglocalAssignmentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: IglocalAssignmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `iglocalAssignments`.
enum IglocalAssignmentsOrderByColumn {
  IGLOCAL_EMPLOYEE_ID
  CLIENT_ID
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `iglocalAssignments`.
input IglocalAssignmentsWhereWhereConditions {
  # The column that is used for the condition.
  column: IglocalAssignmentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [IglocalAssignmentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [IglocalAssignmentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `iglocalAssignments`.
enum IglocalAssignmentsWhereColumn {
  ID
  IGLOCAL_EMPLOYEE_ID
  CLIENT_ID
  CREATED_AT
  UPDATED_AT
}

# A paginated list of IglocalAssignment items.
type IglocalAssignmentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of IglocalAssignment items.
  data: [IglocalAssignment!]!
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeOvertimeRequests`.
input ClientEmployeeOvertimeRequestsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeOvertimeRequestsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeOvertimeRequests`.
enum ClientEmployeeOvertimeRequestsOrderByColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  HOURS_REGISTER
  TYPE
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeOvertimeRequests`.
input ClientEmployeeOvertimeRequestsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeOvertimeRequestsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeOvertimeRequestsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeOvertimeRequestsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeOvertimeRequests`.
enum ClientEmployeeOvertimeRequestsWhereColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  HOURS_REGISTER
  TYPE
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
}

# A paginated list of ClientEmployeeOvertimeRequest items.
type ClientEmployeeOvertimeRequestPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeOvertimeRequest items.
  data: [ClientEmployeeOvertimeRequest!]!
}

type ClientEmployeeOvertimeRequest {
  id: ID!
  client_employee_id: String!
  clientEmployee: ClientEmployee
  start_time: DateTime
  end_time: DateTime
  hours_register: Float!
  type: String!
  reason: String
  descriptions: String!
  status: String!
  approved_by: String
  approved_date: DateTime
  approved_comment: String
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeLeaveRequests`.
input ClientEmployeeLeaveRequestsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeLeaveRequestsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeLeaveRequests`.
enum ClientEmployeeLeaveRequestsOrderByColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  DURATION
  HALF_DAY
  TYPE_OF_LEAVE
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeLeaveRequests`.
input ClientEmployeeLeaveRequestsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeLeaveRequestsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeLeaveRequestsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeLeaveRequestsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeLeaveRequests`.
enum ClientEmployeeLeaveRequestsWhereColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  DURATION
  HALF_DAY
  TYPE_OF_LEAVE
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
}

# Dynamic WHERE conditions for the `hasApproves` argument on the query `clientEmployeeLeaveRequests`.
input ClientEmployeeLeaveRequestsHasApprovesWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeLeaveRequestsHasApprovesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeLeaveRequestsHasApprovesWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeLeaveRequestsHasApprovesWhereConditions!]
}

# Allowed column names for the `hasApproves` argument on the query `clientEmployeeLeaveRequests`.
enum ClientEmployeeLeaveRequestsHasApprovesColumn {
  CREATOR_ID
  ASSIGNEE_ID
}

# A paginated list of ClientEmployeeLeaveRequest items.
type ClientEmployeeLeaveRequestPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeLeaveRequest items.
  data: [ClientEmployeeLeaveRequest!]!
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeEarlyLateRequests`.
input ClientEmployeeEarlyLateRequestsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeEarlyLateRequestsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeEarlyLateRequests`.
enum ClientEmployeeEarlyLateRequestsOrderByColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  TYPE
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeEarlyLateRequests`.
input ClientEmployeeEarlyLateRequestsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeEarlyLateRequestsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeEarlyLateRequestsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeEarlyLateRequestsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeEarlyLateRequests`.
enum ClientEmployeeEarlyLateRequestsWhereColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  TYPE
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
}

# A paginated list of ClientEmployeeEarlyLateRequest items.
type ClientEmployeeEarlyLateRequestPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeEarlyLateRequest items.
  data: [ClientEmployeeEarlyLateRequest!]!
}

type ClientEmployeeEarlyLateRequest {
  id: ID!
  client_employee_id: String!
  clientEmployee: ClientEmployee
  start_time: DateTime
  end_time: DateTime
  duration: Float!
  type: String!
  reason: String
  status: String!
  approved_by: String
  approved_date: DateTime
  approved_comment: String
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `calculationSheets`.
input CalculationSheetsOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `calculationSheets`.
enum CalculationSheetsOrderByColumn {
  CLIENT_ID
  NAME
  FOMULAS
  MONTH
  YEAR
  STATUS
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheets`.
input CalculationSheetsWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheets`.
enum CalculationSheetsWhereColumn {
  CLIENT_ID
  NAME
  FOMULAS
  MONTH
  YEAR
  STATUS
  DATE_TO
  DATE_FROM
}

# Dynamic WHERE conditions for the `hasApproves` argument on the query `calculationSheets`.
input CalculationSheetsHasApprovesWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetsHasApprovesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetsHasApprovesWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetsHasApprovesWhereConditions!]
}

# Allowed column names for the `hasApproves` argument on the query `calculationSheets`.
enum CalculationSheetsHasApprovesColumn {
  CREATOR_ID
  ASSIGNEE_ID
  APPROVED_AT
}

# A paginated list of CalculationSheet items.
type CalculationSheetPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CalculationSheet items.
  data: [CalculationSheet!]!
}

# Order by clause for the `orderBy` argument on the query `calculationSheetsAll`.
input CalculationSheetsAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetsAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `calculationSheetsAll`.
enum CalculationSheetsAllOrderByColumn {
  CLIENT_ID
  NAME
  FOMULAS
  MONTH
  YEAR
  STATUS
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheetsAll`.
input CalculationSheetsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheetsAll`.
enum CalculationSheetsAllWhereColumn {
  CLIENT_ID
  NAME
  FOMULAS
  MONTH
  YEAR
  STATUS
  DATE_TO
  DATE_FROM
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheetMonths`.
input CalculationSheetMonthsWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetMonthsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetMonthsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetMonthsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheetMonths`.
enum CalculationSheetMonthsWhereColumn {
  CLIENT_ID
  MONTH
  YEAR
  STATUS
  DATE_TO
  DATE_FROM
}

type CalculationSheetMonth {
  month: Int
  year: Int
  calculation_sheets_count: Int
}

type ExtListClients {
  data: [ClientExt]
  pagination: CustomPagination
}

type ClientExt {
  id: ID!
  code: String
  company_name: String
  address: String
  static: String
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `calculationSheetClientEmployees`.
input CalculationSheetClientEmployeesOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetClientEmployeesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `calculationSheetClientEmployees`.
enum CalculationSheetClientEmployeesOrderByColumn {
  CALCULATION_SHEET_ID
  CLIENT_EMPLOYEE_ID
  CALCULATED_VALUE
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheetClientEmployees`.
input CalculationSheetClientEmployeesWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetClientEmployeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetClientEmployeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetClientEmployeesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheetClientEmployees`.
enum CalculationSheetClientEmployeesWhereColumn {
  CALCULATION_SHEET_ID
  CLIENT_EMPLOYEE_ID
  CALCULATED_VALUE
}

# A paginated list of CalculationSheetClientEmployee items.
type CalculationSheetClientEmployeePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CalculationSheetClientEmployee items.
  data: [CalculationSheetClientEmployee!]!
}

type CalculationSheetClientEmployee {
  id: ID!
  calculationSheet: CalculationSheet
  clientEmployee: ClientEmployee
  calculated_value: Float!
  is_disabled: DateTime
  calculationSheetVariable: [CalculationSheetVariable]
}

type CalculationSheetVariable {
  id: ID!
  calculation_sheet_id: String!
  client_employee_id: String!
  readable_name: String!
  variable_name: String!
  variable_value: String
}

# Order by clause for the `orderBy` argument on the query `calculationSheetTemplates`.
input CalculationSheetTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `calculationSheetTemplates`.
enum CalculationSheetTemplatesOrderByColumn {
  CLIENT_ID
  NAME
  FOMULAS
  PAYMENT_PERIOD
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheetTemplates`.
input CalculationSheetTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheetTemplates`.
enum CalculationSheetTemplatesWhereColumn {
  ID
  CLIENT_ID
  NAME
  FOMULAS
  PAYMENT_PERIOD
  IS_ENABLED
}

# A paginated list of CalculationSheetTemplate items.
type CalculationSheetTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CalculationSheetTemplate items.
  data: [CalculationSheetTemplate!]!
}

type CalculationSheetTemplate {
  id: ID!
  client_id: String!
  name: String!
  fomulas: String!
  payment_period: String!
  display_columns: String!
  payslip_columns_setting: String
  payslip_accountant_columns_setting: String
  payslip_html_template_en: String
  payslip_html_template_vi: String
  payslip_html_template_ja: String
  is_multilingual: Boolean
  payslip_html_template: String
  enable_cross_ot_calculation: Boolean
  enable_show_payslip_for_employee: Boolean
  enable_notification_new_payroll: Boolean
  cross_ot_start_date: String
  cross_ot_end_date: String
  cross_ot_start_month: Int
  created_at: DateTime!
  updated_at: DateTime!
  is_enabled: Boolean
  template_export_id: String
  assignments: [CalculationSheetTemplateAssignment]
  clientEmployees: [ClientEmployee]!
}

type CalculationSheetTemplateAssignment {
  id: ID!
  client_employee: ClientEmployee!
  template: CalculationSheetTemplate!
  client: Client!
  client_employee_id: String!
  template_id: String!
  client_id: String!
  created_at: DateTime
  updated_at: DateTime
}

# Dynamic WHERE conditions for the `where` argument on the query `allCalculationSheetTemplates`.
input AllCalculationSheetTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: AllCalculationSheetTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AllCalculationSheetTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AllCalculationSheetTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `allCalculationSheetTemplates`.
enum AllCalculationSheetTemplatesWhereColumn {
  ID
  CLIENT_ID
  NAME
  FOMULAS
  PAYMENT_PERIOD
  IS_ENABLED
}

# Order by clause for the `orderBy` argument on the query `calculationSheetVariables`.
input CalculationSheetVariablesOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetVariablesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `calculationSheetVariables`.
enum CalculationSheetVariablesOrderByColumn {
  CALCULATION_SHEET_ID
  CLIENT_EMPLOYEE_ID
  READABLE_NAME
  VARIABLE_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheetVariables`.
input CalculationSheetVariablesWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetVariablesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetVariablesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetVariablesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheetVariables`.
enum CalculationSheetVariablesWhereColumn {
  CALCULATION_SHEET_ID
  CLIENT_EMPLOYEE_ID
  READABLE_NAME
  VARIABLE_NAME
}

# A paginated list of CalculationSheetVariable items.
type CalculationSheetVariablePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CalculationSheetVariable items.
  data: [CalculationSheetVariable!]!
}

# Order by clause for the `orderBy` argument on the query `clientCustomVariables`.
input ClientCustomVariablesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientCustomVariablesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientCustomVariables`.
enum ClientCustomVariablesOrderByColumn {
  CLIENT_ID
  READABLE_NAME
  VARIABLE_NAME
  SCOPE
  VARIABLE_VALUE
  SORT_ORDER
}

# Dynamic WHERE conditions for the `where` argument on the query `clientCustomVariables`.
input ClientCustomVariablesWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientCustomVariablesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientCustomVariablesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientCustomVariablesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientCustomVariables`.
enum ClientCustomVariablesWhereColumn {
  CLIENT_ID
  READABLE_NAME
  VARIABLE_NAME
  SCOPE
  VARIABLE_VALUE
}

# A paginated list of ClientCustomVariable items.
type ClientCustomVariablePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientCustomVariable items.
  data: [ClientCustomVariable!]!
}

type ClientCustomVariable {
  id: ID!
  client_id: String!
  readable_name: String!
  variable_name: String!
  scope: String!
  variable_value: Float!
  sort_order: Int
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeCustomVariables`.
input ClientEmployeeCustomVariablesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeCustomVariablesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeCustomVariables`.
enum ClientEmployeeCustomVariablesOrderByColumn {
  CLIENT_EMPLOYEE_ID
  READABLE_NAME
  VARIABLE_NAME
  VARIABLE_VALUE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeCustomVariables`.
input ClientEmployeeCustomVariablesWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeCustomVariablesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeCustomVariablesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeCustomVariablesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeCustomVariables`.
enum ClientEmployeeCustomVariablesWhereColumn {
  CLIENT_EMPLOYEE_ID
  READABLE_NAME
  VARIABLE_NAME
  VARIABLE_VALUE
}

# A paginated list of ClientEmployeeCustomVariable items.
type ClientEmployeeCustomVariablePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeCustomVariable items.
  data: [ClientEmployeeCustomVariable!]!
}

type ClientEmployeeCustomVariable {
  id: ID!
  client_employee_id: String!
  readable_name: String!
  variable_name: String!
  variable_value: Float!
  created_at: DateTime!
  updated_at: DateTime!
}

# A paginated list of User items.
type UserPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of User items.
  data: [User!]!
}

type Me {
  id: ID!
  client_id: String!
  username: String!
  name: String!
  email: String!
  changed_random_password: Int!
  client: Client
  clientEmployee: ClientEmployee
  iGlocalEmployee: IglocalEmployee
  assignedApproves: [Approve]
  assigned_approves_count: Int!
  permissions: String
  created_at: DateTime!
  updated_at: DateTime!
  prefered_language: String
  selfEvaluation: Boolean
  otherEvaluation: Boolean
  is_internal: Int
  timezone_name: String
  is_email_notification: Boolean
  is_active: Boolean
}

# Order by clause for the `orderBy` argument on the query `supportTickets`.
input SupportTicketsOrderByOrderByClause {
  # The column that is used for ordering.
  field: SupportTicketsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `supportTickets`.
enum SupportTicketsOrderByColumn {
  CLIENT_ID
  USER_ID
  SUBJECT
  CATEGORY
  PRIORITY
  STATUS
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `supportTickets`.
input SupportTicketsWhereWhereConditions {
  # The column that is used for the condition.
  column: SupportTicketsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SupportTicketsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SupportTicketsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `supportTickets`.
enum SupportTicketsWhereColumn {
  CLIENT_ID
  USER_ID
  SUBJECT
  CATEGORY
  PRIORITY
  STATUS
  CREATED_AT
  UPDATED_AT
}

# A paginated list of SupportTicket items.
type SupportTicketPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of SupportTicket items.
  data: [SupportTicket!]!
}

type SupportTicket {
  id: ID!
  client: Client
  user: User!
  subject: String
  category: String
  priority: String
  status: String
  message: String
  assigned: User
  supportTicketComments: [SupportTicketComment]
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type SupportTicketComment {
  id: ID!
  supportTicket: SupportTicket
  user: User!
  message: String
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `supportTicketComments`.
input SupportTicketCommentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: SupportTicketCommentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `supportTicketComments`.
enum SupportTicketCommentsOrderByColumn {
  SUPPORT_TICKET_ID
  USER_COMMENT_ID
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `supportTicketComments`.
input SupportTicketCommentsWhereWhereConditions {
  # The column that is used for the condition.
  column: SupportTicketCommentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SupportTicketCommentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SupportTicketCommentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `supportTicketComments`.
enum SupportTicketCommentsWhereColumn {
  SUPPORT_TICKET_ID
  USER_COMMENT_ID
  MESSAGE
  CREATED_AT
  UPDATED_AT
}

# A paginated list of SupportTicketComment items.
type SupportTicketCommentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of SupportTicketComment items.
  data: [SupportTicketComment!]!
}

# Order by clause for the `orderBy` argument on the query `formulas`.
input FormulasOrderByOrderByClause {
  # The column that is used for ordering.
  field: FormulasOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `formulas`.
enum FormulasOrderByColumn {
  NAME
  FUNC_NAME
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `formulas`.
input FormulasWhereWhereConditions {
  # The column that is used for the condition.
  column: FormulasWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [FormulasWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [FormulasWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `formulas`.
enum FormulasWhereColumn {
  NAME
  FUNC_NAME
}

# A paginated list of Formula items.
type FormulaPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Formula items.
  data: [Formula!]!
}

type Formula {
  id: ID!
  name: String
  func_name: String
  parameters: [String]
  formula: String
  description: String
  deleted_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `workSchedules`.
input WorkSchedulesOrderByOrderByClause {
  # The column that is used for ordering.
  field: WorkSchedulesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `workSchedules`.
enum WorkSchedulesOrderByColumn {
  SCHEDULE_DATE
}

type WorkSchedule {
  id: String
  client_id: String
  schedule_date: Date
  check_in: String
  check_out: String
  start_break: String
  end_break: String
  rest_hours: String
  is_holiday: Boolean
  is_off_day: Boolean
  work_schedule_group_id: String
}

# Order by clause for the `orderBy` argument on the query `workScheduleGroups`.
input WorkScheduleGroupsOrderByOrderByClause {
  # The column that is used for ordering.
  field: WorkScheduleGroupsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `workScheduleGroups`.
enum WorkScheduleGroupsOrderByColumn {
  NAME
  TIMESHEET_DEADLINE_AT
  TIMESHEET_FROM
}

# Dynamic WHERE conditions for the `where` argument on the query `workScheduleGroups`.
input WorkScheduleGroupsWhereWhereConditions {
  # The column that is used for the condition.
  column: WorkScheduleGroupsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WorkScheduleGroupsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WorkScheduleGroupsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `workScheduleGroups`.
enum WorkScheduleGroupsWhereColumn {
  ID
  CLIENT_ID
  NAME
  WORK_SCHEDULE_GROUP_TEMPLATE_ID
  TIMESHEET_DEADLINE_AT
  TIMESHEET_FROM
  TIMESHEET_TO
}

# A paginated list of WorkScheduleGroup items.
type WorkScheduleGroupPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of WorkScheduleGroup items.
  data: [WorkScheduleGroup!]!
}

type WorkScheduleGroup {
  id: String
  work_schedule_group_template_id: String
  client_id: String
  name: String
  timesheet_from: Date
  timesheet_to: Date
  rest_hours: String
  timesheet_deadline_at: DateTime
  expected_work_hours: Float
}

# Order by clause for the `orderBy` argument on the query `workScheduleGroupTemplates`.
input WorkScheduleGroupTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: WorkScheduleGroupTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `workScheduleGroupTemplates`.
enum WorkScheduleGroupTemplatesOrderByColumn {
  NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `workScheduleGroupTemplates`.
input WorkScheduleGroupTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: WorkScheduleGroupTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WorkScheduleGroupTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WorkScheduleGroupTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `workScheduleGroupTemplates`.
enum WorkScheduleGroupTemplatesWhereColumn {
  NAME
  ID
  CLIENT_ID
}

type WorkScheduleGroupTemplate {
  id: String
  client_id: String
  name: String
  check_in: String
  check_out: String
  rest_hours: String
  start_break: String
  end_break: String
  work_days: String
  is_default: Boolean
  timesheet_deadline_days: Int
  period_start_date: Int
  period_end_date: Int
  period_end_month: Int
}

# Order by clause for the `orderBy` argument on the query `getClientWorkflowSetting`.
input GetClientWorkflowSettingOrderByOrderByClause {
  # The column that is used for ordering.
  field: GetClientWorkflowSettingOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `getClientWorkflowSetting`.
enum GetClientWorkflowSettingOrderByColumn {
  ENABLE_OVERTIME_REQUEST
  ENABLE_LEAVE_REQUEST
  ENABLE_EARLY_LEAVE_REQUEST
}

# Dynamic WHERE conditions for the `where` argument on the query `approves`.
input ApprovesWhereWhereConditions {
  # The column that is used for the condition.
  column: ApprovesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ApprovesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ApprovesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `approves`.
enum ApprovesWhereColumn {
  ID
  APPROVED_AT
  DECLINED_AT
  ASSIGNEE_ID
  TYPE
  STEP
  CLIENT_ID
  CREATOR_ID
  TARGET_ID
  APPROVE_GROUP_ID
  ORIGINAL_CREATOR_ID
}

# Order by clause for the `orderBy` argument on the query `approves`.
input ApprovesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ApprovesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `approves`.
enum ApprovesOrderByColumn {
  CREATED_AT
  TYPE
  TARGET_ID
  STEP
}

# A paginated list of Approve items.
type ApprovePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Approve items.
  data: [Approve!]!
}

# Order by clause for the `orderBy` argument on the query `clientAssignments`.
input ClientAssignmentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientAssignmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientAssignments`.
enum ClientAssignmentsOrderByColumn {
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientAssignments`.
input ClientAssignmentsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientAssignmentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientAssignmentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientAssignmentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientAssignments`.
enum ClientAssignmentsWhereColumn {
  STAFF_ID
  LEADER_ID
  CLIENT_ID
  CREATED_AT
  UPDATED_AT
}

# A paginated list of ClientAssignment items.
type ClientAssignmentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientAssignment items.
  data: [ClientAssignment!]!
}

# Order by clause for the `orderBy` argument on the query `KnowledgeQuestions`.
input KnowledgeQuestionsOrderByOrderByClause {
  # The column that is used for ordering.
  field: KnowledgeQuestionsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `KnowledgeQuestions`.
enum KnowledgeQuestionsOrderByColumn {
  QUESTION
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `KnowledgeQuestions`.
input KnowledgeQuestionsWhereWhereConditions {
  # The column that is used for the condition.
  column: KnowledgeQuestionsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [KnowledgeQuestionsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [KnowledgeQuestionsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `KnowledgeQuestions`.
enum KnowledgeQuestionsWhereColumn {
  QUESTION
  ANSWER
  TAGS
  LANGUAGE
}

# A paginated list of KnowledgeQuestion items.
type KnowledgeQuestionPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of KnowledgeQuestion items.
  data: [KnowledgeQuestion!]!
}

type KnowledgeQuestion {
  id: ID!
  question: String
  answer: String
  tags: String
  language: String
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `KnowledgeQuestionsAll`.
input KnowledgeQuestionsAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: KnowledgeQuestionsAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `KnowledgeQuestionsAll`.
enum KnowledgeQuestionsAllOrderByColumn {
  QUESTION
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `KnowledgeQuestionsAll`.
input KnowledgeQuestionsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: KnowledgeQuestionsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [KnowledgeQuestionsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [KnowledgeQuestionsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `KnowledgeQuestionsAll`.
enum KnowledgeQuestionsAllWhereColumn {
  QUESTION
  ANSWER
  TAGS
  LANGUAGE
}

type DebitNote {
  id: ID!
  client_id: String!
  batch_no: String!
  calculation_sheet_id: String!
  status: String!
  created_at: String
  calculationSheet: CalculationSheet
}

# Order by clause for the `orderBy` argument on the query `socialSecurityProfiles`.
input SocialSecurityProfilesOrderByOrderByClause {
  # The column that is used for ordering.
  field: SocialSecurityProfilesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `socialSecurityProfiles`.
enum SocialSecurityProfilesOrderByColumn {
  STATUS
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `socialSecurityProfiles`.
input SocialSecurityProfilesWhereWhereConditions {
  # The column that is used for the condition.
  column: SocialSecurityProfilesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SocialSecurityProfilesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SocialSecurityProfilesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `socialSecurityProfiles`.
enum SocialSecurityProfilesWhereColumn {
  STATUS
  CLIENT_EMPLOYEE_ID
  CLIENT_ID
}

# A paginated list of SocialSecurityProfile items.
type SocialSecurityProfilePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of SocialSecurityProfile items.
  data: [SocialSecurityProfile!]!
}

type SocialSecurityProfile {
  id: ID!
  client_id: String!
  client_employee_id: String!
  social_insurance_number: String
  social_insurance_number_no: String
  effective_date_of_social_insurance: String
  salary_for_social_insurance_payment: String
  status: String!
  tinh_trang: String
  tinh_trang_type: String
  tinh_trang_type_sub: String
  tinh_trang_from_date: String
  tinh_trang_to_date: String
  noi_dang_ki_kcb_ban_dau: String
  muc_luong_dieu_chinh: String
  chuc_vu_dieu_chinh: String
  tinh_trang_chung_tu_lien_quan: String
  ngay_ke_khai_va_luu_tam_ho_so: String
  ngay_nop_ho_so: String
  so_ho_so_bhxh_da_ke_khai: String
  ngay_hen_tra_ket_qua: String
  tinh_trang_phia_khach_hang: String
  comment: String
  created_at: String
  clientEmployee: ClientEmployee
  media_path: String
  mediaTemp: [MediaTemp]
}

type SocialSecurityProfileHistory {
  id: ID
  client_id: String
  client_employee_id: String
  old_status: String
  new_status: String
  salary_for_social_insurance_payment: String
  comment: String
  created_at: String
}

type SocialSecurityProfilePaginate {
  data: [SocialSecurityProfile]
  pagination: CustomPagination
}

type TranslationPaginatePaginate {
  data: [Translation]
  pagination: CustomPagination
}

type Translation {
  id: String
  language_id: String
  translatable_id: String
  translation: String
}

# Order by clause for the `orderBy` argument on the query `calculationSheetTemplateAssignments`.
input CalculationSheetTemplateAssignmentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetTemplateAssignmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `calculationSheetTemplateAssignments`.
enum CalculationSheetTemplateAssignmentsOrderByColumn {
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `calculationSheetTemplateAssignments`.
input CalculationSheetTemplateAssignmentsWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetTemplateAssignmentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetTemplateAssignmentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetTemplateAssignmentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `calculationSheetTemplateAssignments`.
enum CalculationSheetTemplateAssignmentsWhereColumn {
  ID
  CLIENT_EMPLOYEE_ID
  TEMPLATE_ID
  CLIENT_ID
  CREATED_AT
  UPDATED_AT
}

# A paginated list of CalculationSheetTemplateAssignment items.
type CalculationSheetTemplateAssignmentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CalculationSheetTemplateAssignment items.
  data: [CalculationSheetTemplateAssignment!]!
}

# Order by clause for the `orderBy` argument on the query `YearHolidays`.
input YearHolidaysOrderByOrderByClause {
  # The column that is used for ordering.
  field: YearHolidaysOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `YearHolidays`.
enum YearHolidaysOrderByColumn {
  YEAR
  DAY
}

# Dynamic WHERE conditions for the `where` argument on the query `YearHolidays`.
input YearHolidaysWhereWhereConditions {
  # The column that is used for the condition.
  column: YearHolidaysWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [YearHolidaysWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [YearHolidaysWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `YearHolidays`.
enum YearHolidaysWhereColumn {
  YEAR
  DAY
  ID
}

# A paginated list of YearHoliday items.
type YearHolidayPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of YearHoliday items.
  data: [YearHoliday!]!
}

type YearHoliday {
  id: ID!
  year: String
  day: String
}

# Order by clause for the `orderBy` argument on the query `YearHolidaysAll`.
input YearHolidaysAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: YearHolidaysAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `YearHolidaysAll`.
enum YearHolidaysAllOrderByColumn {
  YEAR
  DAY
}

# Dynamic WHERE conditions for the `where` argument on the query `YearHolidaysAll`.
input YearHolidaysAllWhereWhereConditions {
  # The column that is used for the condition.
  column: YearHolidaysAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [YearHolidaysAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [YearHolidaysAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `YearHolidaysAll`.
enum YearHolidaysAllWhereColumn {
  YEAR
  DAY
  ID
}

# Order by clause for the `orderBy` argument on the query `CalculationSheetExportTemplates`.
input CalculationSheetExportTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetExportTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `CalculationSheetExportTemplates`.
enum CalculationSheetExportTemplatesOrderByColumn {
  NAME
  FILE_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `CalculationSheetExportTemplates`.
input CalculationSheetExportTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetExportTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetExportTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetExportTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `CalculationSheetExportTemplates`.
enum CalculationSheetExportTemplatesWhereColumn {
  NAME
  FILE_NAME
  ID
  CLIENT_ID
}

# A paginated list of CalculationSheetExportTemplate items.
type CalculationSheetExportTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of CalculationSheetExportTemplate items.
  data: [CalculationSheetExportTemplate!]!
}

type CalculationSheetExportTemplate {
  id: ID!
  name: String
  client_id: String
  client: Client
  path: String
  mediaTemp: [MediaTemp]
  media_path: String
}

# Order by clause for the `orderBy` argument on the query `CalculationSheetExportTemplatesAll`.
input CalculationSheetExportTemplatesAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: CalculationSheetExportTemplatesAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `CalculationSheetExportTemplatesAll`.
enum CalculationSheetExportTemplatesAllOrderByColumn {
  NAME
  FILE_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `CalculationSheetExportTemplatesAll`.
input CalculationSheetExportTemplatesAllWhereWhereConditions {
  # The column that is used for the condition.
  column: CalculationSheetExportTemplatesAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CalculationSheetExportTemplatesAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CalculationSheetExportTemplatesAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `CalculationSheetExportTemplatesAll`.
enum CalculationSheetExportTemplatesAllWhereColumn {
  NAME
  FILE_NAME
  ID
  CLIENT_ID
}

# Order by clause for the `orderBy` argument on the query `socialSecurityClaims`.
input SocialSecurityClaimsOrderByOrderByClause {
  # The column that is used for ordering.
  field: SocialSecurityClaimsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `socialSecurityClaims`.
enum SocialSecurityClaimsOrderByColumn {
  STATE
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `socialSecurityClaims`.
input SocialSecurityClaimsWhereWhereConditions {
  # The column that is used for the condition.
  column: SocialSecurityClaimsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SocialSecurityClaimsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SocialSecurityClaimsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `socialSecurityClaims`.
enum SocialSecurityClaimsWhereColumn {
  STATE
  CLIENT_APPROVED
  CLIENT_EMPLOYEE_ID
  CLIENT_ID
}

# Dynamic WHERE conditions for the `hasApproves` argument on the query `socialSecurityClaims`.
input SocialSecurityClaimsHasApprovesWhereConditions {
  # The column that is used for the condition.
  column: SocialSecurityClaimsHasApprovesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SocialSecurityClaimsHasApprovesWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SocialSecurityClaimsHasApprovesWhereConditions!]
}

# Allowed column names for the `hasApproves` argument on the query `socialSecurityClaims`.
enum SocialSecurityClaimsHasApprovesColumn {
  CREATOR_ID
  ASSIGNEE_ID
}

# Dynamic WHERE conditions for the `hasclientEmployee` argument on the query `socialSecurityClaims`.
input SocialSecurityClaimsHasclientEmployeeWhereConditions {
  # The column that is used for the condition.
  column: SocialSecurityClaimsHasclientEmployeeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SocialSecurityClaimsHasclientEmployeeWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SocialSecurityClaimsHasclientEmployeeWhereConditions!]
}

# Allowed column names for the `hasclientEmployee` argument on the query `socialSecurityClaims`.
enum SocialSecurityClaimsHasclientEmployeeColumn {
  CODE
}

# A paginated list of SocialSecurityClaim items.
type SocialSecurityClaimPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of SocialSecurityClaim items.
  data: [SocialSecurityClaim!]!
}

type SocialSecurityClaim {
  id: ID!
  client_id: String!
  client_employee_id: String!
  clientEmployee: ClientEmployee
  state: String
  client_approved: Int
  social_insurance_number: String!
  claimed_amount: Int
  reason: String
  cd_claim_bao_hiem: String
  cd_claim_bao_hiem_sub: String
  cd_claim_bao_hiem_sub_sub: String
  cd_claim_bh_tu_ngay: String
  cd_claim_bh_den_ngay: String
  cd_claim_bh_tong_so_ngay_nghi: String
  cd_om_dau_ten_benh: String
  cd_om_dau_tuyen_benh_vien: String
  cd_om_dau_benh_dai_ngay: String
  cd_thai_san_ngay_sinh_con: String
  cd_thai_san_phau_thuat_thai_duoi_32t: String
  cd_thai_san_nghi_duong_thai: String
  cd_thai_san_ngay_nhan_con_nuoi: String
  cd_thai_san_tuoi_thai: String
  cd_thai_san_bien_phap_tranh_thai: String
  cd_thai_san_dieu_kien_sinh_con: String
  cd_thai_san_dieu_kien_khi_kham_thai: String
  cd_thai_san_cha_nghi_cham_con: String
  cd_thai_san_ngay_di_lam_thuc_te: String
  cd_thai_san_ngay_con_chet: String
  cd_thai_san_so_con_chet_khi_sinh: String
  cd_thai_san_ngay_me_chet: String
  cd_thai_san_ngay_ket_luan: String
  ds_ph_suc_khoe_ngay_tro_lai_lam_viec: String
  ds_ph_suc_khoe_ngay_dam_dinh: String
  tinh_trang_chung_tu_lien_quan: String
  ttgqhs_ngay_nop_ho_so: String
  ttgqhs_ngay_hen_tra_ket_qua: String
  ttgqhs_so_ho_so_bhxh_da_ke_khai: String
  ttgqhs_tong_so_ngay_duoc_tinh_huong_tro_cap: String
  ttgqhs_so_tien_duoc_huong: String
  ngay_ke_khai_va_luu_tam_ho_so: String
  ngay_tra_ket_qua: String
  bo_phan_cd_bhxh_date: String
  bo_phan_cd_bhxh_reviewer: String
  bo_phan_khtc_date: String
  bo_phan_khtc_reviewer: String
  bo_phan_tn_tkq_date: String
  bo_phan_tn_tkq_reviewer: String
  rejected_comment: String
  note: String
  created_at: String
  updated_at: String
}

# Order by clause for the `orderBy` argument on the query `approveFlowsAll`.
input ApproveFlowsAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: ApproveFlowsAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `approveFlowsAll`.
enum ApproveFlowsAllOrderByColumn {
  FLOW_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `approveFlowsAll`.
input ApproveFlowsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: ApproveFlowsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ApproveFlowsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ApproveFlowsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `approveFlowsAll`.
enum ApproveFlowsAllWhereColumn {
  CLIENT_ID
  FLOW_NAME
}

type ApproveFlow {
  id: String
  step: Int
  flow_name: String
  created_at: DateTime
  updated_at: DateTime
  approveFlowUsers: [ApproveFlowUser]
}

type ApproveFlowUser {
  id: String
  approve_flow_id: String
  created_at: DateTime
  updated_at: DateTime
  user: User
}

# Order by clause for the `orderBy` argument on the query `payrollAccountantExportTemplates`.
input PayrollAccountantExportTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: PayrollAccountantExportTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `payrollAccountantExportTemplates`.
enum PayrollAccountantExportTemplatesOrderByColumn {
  NAME
  FILE_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `payrollAccountantExportTemplates`.
input PayrollAccountantExportTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: PayrollAccountantExportTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PayrollAccountantExportTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PayrollAccountantExportTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `payrollAccountantExportTemplates`.
enum PayrollAccountantExportTemplatesWhereColumn {
  NAME
  FILE_NAME
  ID
  CLIENT_ID
}

# A paginated list of PayrollAccountantExportTemplate items.
type PayrollAccountantExportTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PayrollAccountantExportTemplate items.
  data: [PayrollAccountantExportTemplate!]!
}

type PayrollAccountantExportTemplate {
  id: ID!
  client_id: String
  template_variables: String
  name: String
  media_path: String
  mediaTemp: [MediaTemp]
  path: String
}

# Order by clause for the `orderBy` argument on the query `payrollAccountantExportTemplatesAll`.
input PayrollAccountantExportTemplatesAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: PayrollAccountantExportTemplatesAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `payrollAccountantExportTemplatesAll`.
enum PayrollAccountantExportTemplatesAllOrderByColumn {
  NAME
  FILE_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `payrollAccountantExportTemplatesAll`.
input PayrollAccountantExportTemplatesAllWhereWhereConditions {
  # The column that is used for the condition.
  column: PayrollAccountantExportTemplatesAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PayrollAccountantExportTemplatesAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PayrollAccountantExportTemplatesAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `payrollAccountantExportTemplatesAll`.
enum PayrollAccountantExportTemplatesAllWhereColumn {
  NAME
  FILE_NAME
  ID
  CLIENT_ID
}

# Order by clause for the `orderBy` argument on the query `payrollAccountantTemplates`.
input PayrollAccountantTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: PayrollAccountantTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `payrollAccountantTemplates`.
enum PayrollAccountantTemplatesOrderByColumn {
  CLIENT_ID
  GROUP_TYPE
}

# Dynamic WHERE conditions for the `where` argument on the query `payrollAccountantTemplates`.
input PayrollAccountantTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: PayrollAccountantTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PayrollAccountantTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PayrollAccountantTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `payrollAccountantTemplates`.
enum PayrollAccountantTemplatesWhereColumn {
  ID
  CLIENT_ID
  GROUP_TYPE
}

# A paginated list of PayrollAccountantTemplate items.
type PayrollAccountantTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PayrollAccountantTemplate items.
  data: [PayrollAccountantTemplate!]!
}

type PayrollAccountantTemplate {
  id: ID!
  client_id: String!
  loop_direction: String
  title: String
  group_type: String
  template_columns: JSON
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `clientLogs`.
input ClientLogsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientLogsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientLogs`.
enum ClientLogsOrderByColumn {
  CLIENT_ID
  LOG_TYPE
  LOG_CONTENT
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientLogs`.
input ClientLogsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientLogsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientLogsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientLogsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientLogs`.
enum ClientLogsWhereColumn {
  CLIENT_ID
  LOG_TYPE
  LOG_CONTENT
  CREATED_AT
}

# A paginated list of ClientLog items.
type ClientLogPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientLog items.
  data: [ClientLog!]!
}

type ClientLog {
  id: ID!
  client_id: String!
  log_type: String!
  log_content: String!
  created_at: DateTime!
  updated_at: DateTime!
}

type ListClientLogs {
  data: String
  pagination: CustomPagination
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeContracts`.
input ClientEmployeeContractsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeContractsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeContracts`.
enum ClientEmployeeContractsOrderByColumn {
  CONTRACT_TYPE
  CONTRACT_CODE
  CONTRACT_SIGNING_DATE
  CONTRACT_END_DATE
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeContracts`.
input ClientEmployeeContractsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeContractsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeContractsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeContractsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeContracts`.
enum ClientEmployeeContractsWhereColumn {
  CLIENT_EMPLOYEE_ID
  CONTRACT_TYPE
  CONTRACT_CODE
}

# A paginated list of ClientEmployeeContract items.
type ClientEmployeeContractPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeContract items.
  data: [ClientEmployeeContract!]!
}

# Order by clause for the `orderBy` argument on the query `emailTemplates`.
input EmailTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: EmailTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `emailTemplates`.
enum EmailTemplatesOrderByColumn {
  TEMPLATE_NAME
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `emailTemplates`.
input EmailTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: EmailTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [EmailTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [EmailTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `emailTemplates`.
enum EmailTemplatesWhereColumn {
  TEMPLATE_NAME
  CREATED_AT
}

# A paginated list of EmailTemplate items.
type EmailTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of EmailTemplate items.
  data: [EmailTemplate!]!
}

type EmailTemplate {
  id: ID!
  template_name: String!
  content_en: String
  content_vi: String
  content_ja: String
  subject_en: String
  subject_vi: String
  subject_ja: String
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `clientWifiCheckinSpots`.
input ClientWifiCheckinSpotsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientWifiCheckinSpotsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientWifiCheckinSpots`.
enum ClientWifiCheckinSpotsOrderByColumn {
  CLIENT_ID
  SPOT_NAME
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientWifiCheckinSpots`.
input ClientWifiCheckinSpotsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientWifiCheckinSpotsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientWifiCheckinSpotsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientWifiCheckinSpotsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientWifiCheckinSpots`.
enum ClientWifiCheckinSpotsWhereColumn {
  ID
  CLIENT_ID
  SPOT_NAME
  SPOT_SSID
  SPOT_MAC
}

# A paginated list of ClientWifiCheckinSpot items.
type ClientWifiCheckinSpotPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientWifiCheckinSpot items.
  data: [ClientWifiCheckinSpot!]!
}

type ClientWifiCheckinSpot {
  id: ID!
  client_id: String!
  spot_name: String!
  spot_ssid: String!
  spot_mac: String!
  memo: String
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `trainingSeminars`.
input TrainingSeminarsOrderByOrderByClause {
  # The column that is used for ordering.
  field: TrainingSeminarsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `trainingSeminars`.
enum TrainingSeminarsOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `trainingSeminars`.
input TrainingSeminarsWhereWhereConditions {
  # The column that is used for the condition.
  column: TrainingSeminarsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [TrainingSeminarsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [TrainingSeminarsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `trainingSeminars`.
enum TrainingSeminarsWhereColumn {
  ID
  CODE
  NAME
  CLIENT_ID
  CATEGORY_RANK
  CATEGORY_STAGE
}

# A paginated list of TrainingSeminar items.
type TrainingSeminarPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of TrainingSeminar items.
  data: [TrainingSeminar!]!
}

type TrainingSeminar {
  id: ID!
  client_id: String!
  code: String!
  name: String!
  category_rank: String!
  category_stage: String!
  start_date: Date!
  end_date: Date
  created_at: DateTime!
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `trainingSeminarsAll`.
input TrainingSeminarsAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: TrainingSeminarsAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `trainingSeminarsAll`.
enum TrainingSeminarsAllOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `trainingSeminarsAll`.
input TrainingSeminarsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: TrainingSeminarsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [TrainingSeminarsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [TrainingSeminarsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `trainingSeminarsAll`.
enum TrainingSeminarsAllWhereColumn {
  ID
  CODE
  NAME
  CLIENT_ID
  CATEGORY_RANK
  CATEGORY_STAGE
}

# Order by clause for the `orderBy` argument on the query `clientAppliedDocuments`.
input ClientAppliedDocumentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientAppliedDocumentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientAppliedDocuments`.
enum ClientAppliedDocumentsOrderByColumn {
  CLIENT_ID
  DOCUMENT_TYPE
  STATUS
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientAppliedDocuments`.
input ClientAppliedDocumentsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientAppliedDocumentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientAppliedDocumentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientAppliedDocumentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientAppliedDocuments`.
enum ClientAppliedDocumentsWhereColumn {
  ID
  CLIENT_ID
  DOCUMENT_TYPE
  STATUS
  CREATED_AT
}

# A paginated list of ClientAppliedDocument items.
type ClientAppliedDocumentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientAppliedDocument items.
  data: [ClientAppliedDocument!]!
}

type ClientAppliedDocument {
  id: ID!
  client_id: String!
  user_id: String!
  code: String!
  document_type: String!
  status: String!
  user: User!
  created_at: DateTime!
  updated_at: DateTime!
  media_path: String
  mediaTemp: [MediaTemp]
  category: AppliedDocumentCategory
}

type AppliedDocumentCategory {
  id: ID!
  name: String
  parent: AppliedDocumentCategory
  children: [AppliedDocumentCategory]
  parent_id: String
  created_at: DateTime
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `comments`.
input CommentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: CommentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `comments`.
enum CommentsOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `comments`.
input CommentsWhereWhereConditions {
  # The column that is used for the condition.
  column: CommentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [CommentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [CommentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `comments`.
enum CommentsWhereColumn {
  ID
  USER_ID
  TARGET_ID
  TARGET_TYPE
}

type Comment {
  id: ID!
  user_id: String!
  user: User
  message: String!
  created_at: DateTime!
  updated_at: DateTime!
  target_type: String
  target_id: String
  media_path: String
  media: [Media]
}

# Order by clause for the `orderBy` argument on the query `worktimeRegisters`.
input WorktimeRegistersOrderByOrderByClause {
  # The column that is used for ordering.
  field: WorktimeRegistersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `worktimeRegisters`.
enum WorktimeRegistersOrderByColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
  CREATED_AT
  CODE
  FULL_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `worktimeRegisters`.
input WorktimeRegistersWhereWhereConditions {
  # The column that is used for the condition.
  column: WorktimeRegistersWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WorktimeRegistersWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WorktimeRegistersWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `worktimeRegisters`.
enum WorktimeRegistersWhereColumn {
  CLIENT_EMPLOYEE_ID
  START_TIME
  END_TIME
  REASON
  STATUS
  APPROVED_BY
  APPROVED_DATE
  CREATED_AT
  TYPE
}

# Dynamic WHERE conditions for the `hasApproves` argument on the query `worktimeRegisters`.
input WorktimeRegistersHasApprovesWhereConditions {
  # The column that is used for the condition.
  column: WorktimeRegistersHasApprovesColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WorktimeRegistersHasApprovesWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WorktimeRegistersHasApprovesWhereConditions!]
}

# Allowed column names for the `hasApproves` argument on the query `worktimeRegisters`.
enum WorktimeRegistersHasApprovesColumn {
  CREATOR_ID
  ASSIGNEE_ID
}

# A paginated list of WorktimeRegister items.
type WorktimeRegisterPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of WorktimeRegister items.
  data: [WorktimeRegister!]!
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeTrainingSeminars`.
input ClientEmployeeTrainingSeminarsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeTrainingSeminarsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeTrainingSeminars`.
enum ClientEmployeeTrainingSeminarsOrderByColumn {
  CREATED_AT
  STATE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeTrainingSeminars`.
input ClientEmployeeTrainingSeminarsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeTrainingSeminarsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeTrainingSeminarsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeTrainingSeminarsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeTrainingSeminars`.
enum ClientEmployeeTrainingSeminarsWhereColumn {
  ID
  CLIENT_EMPLOYEE_ID
  TRAINING_SEMINAR_ID
  CLIENT_ID
  STATE
  START_DATE
  END_DATE
}

# A paginated list of ClientEmployeeTrainingSeminar items.
type ClientEmployeeTrainingSeminarPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeTrainingSeminar items.
  data: [ClientEmployeeTrainingSeminar!]!
}

type ClientEmployeeTrainingSeminar {
  id: ID!
  client_id: String!
  client_employee_id: String!
  training_seminar_id: String!
  start_date: Date!
  end_date: Date
  state: String!
  created_at: DateTime!
  updated_at: DateTime
  clientEmployee: ClientEmployee
  trainingSeminar: TrainingSeminar
}

# Order by clause for the `orderBy` argument on the query `clientEmployeeTrainingSeminarAll`.
input ClientEmployeeTrainingSeminarAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientEmployeeTrainingSeminarAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientEmployeeTrainingSeminarAll`.
enum ClientEmployeeTrainingSeminarAllOrderByColumn {
  CREATED_AT
  STATE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeTrainingSeminarAll`.
input ClientEmployeeTrainingSeminarAllWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeTrainingSeminarAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeTrainingSeminarAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeTrainingSeminarAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeTrainingSeminarAll`.
enum ClientEmployeeTrainingSeminarAllWhereColumn {
  ID
  CLIENT_EMPLOYEE_ID
  TRAINING_SEMINAR_ID
  CLIENT_ID
  STATE
  START_DATE
  END_DATE
}

type ClientEmployeeTrainingSeminarPaginate {
  data: [ClientEmployeeTrainingSeminarReport]
  pagination: CustomPagination
}

type ClientEmployeeTrainingSeminarReport {
  id: ID!
  client_id: String!
  code: String!
  full_name: String
  department: String
  position: String
  title: String
  training_seminar_total_joining: String
  training_seminar_total_completed: String
  avatar_path: String
  avatar_path_large: String
}

# Order by clause for the `orderBy` argument on the query `contracts`.
input ContractsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ContractsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `contracts`.
enum ContractsOrderByColumn {
  CREATED_AT
  CONTRACT_TYPE
}

# Dynamic WHERE conditions for the `where` argument on the query `contracts`.
input ContractsWhereWhereConditions {
  # The column that is used for the condition.
  column: ContractsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ContractsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ContractsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `contracts`.
enum ContractsWhereColumn {
  CLIENT_ID
  NAME
  CONTRACT_TYPE
  CONTRACT_NO
  CREATED_AT
  CONTRACT_VARIABLES
}

# A paginated list of Contract items.
type ContractPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Contract items.
  data: [Contract!]!
}

type Contract {
  id: ID!
  client_id: String!
  name: String!
  contract_type: String!
  contract_variables: String
  contract_no: String!
  note: String!
  created_at: DateTime
  updated_at: DateTime
  path: String
  client: Client
}

# Order by clause for the `orderBy` argument on the query `contractTemplates`.
input ContractTemplatesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ContractTemplatesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `contractTemplates`.
enum ContractTemplatesOrderByColumn {
  CREATED_AT
  CONTRACT_TYPE
}

# Dynamic WHERE conditions for the `where` argument on the query `contractTemplates`.
input ContractTemplatesWhereWhereConditions {
  # The column that is used for the condition.
  column: ContractTemplatesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ContractTemplatesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ContractTemplatesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `contractTemplates`.
enum ContractTemplatesWhereColumn {
  ID
  CLIENT_ID
  NAME
  CONTRACT_TYPE
  CREATED_AT
}

# A paginated list of ContractTemplate items.
type ContractTemplatePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ContractTemplate items.
  data: [ContractTemplate!]!
}

type ContractTemplate {
  id: ID!
  client_id: String!
  name: String!
  contract_type: String!
  contract_variables: String
  note: String
  created_at: DateTime!
  updated_at: DateTime
  media_path: String
  mediaTemp: [MediaTemp]
}

# Order by clause for the `orderBy` argument on the query `contractTemplatesAll`.
input ContractTemplatesAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: ContractTemplatesAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `contractTemplatesAll`.
enum ContractTemplatesAllOrderByColumn {
  NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `contractTemplatesAll`.
input ContractTemplatesAllWhereWhereConditions {
  # The column that is used for the condition.
  column: ContractTemplatesAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ContractTemplatesAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ContractTemplatesAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `contractTemplatesAll`.
enum ContractTemplatesAllWhereColumn {
  ID
  CLIENT_ID
  NAME
  CONTRACT_TYPE
  CREATED_AT
}

# Order by clause for the `orderBy` argument on the query `jobboardSettings`.
input JobboardSettingsOrderByOrderByClause {
  # The column that is used for ordering.
  field: JobboardSettingsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `jobboardSettings`.
enum JobboardSettingsOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `jobboardSettings`.
input JobboardSettingsWhereWhereConditions {
  # The column that is used for the condition.
  column: JobboardSettingsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [JobboardSettingsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [JobboardSettingsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `jobboardSettings`.
enum JobboardSettingsWhereColumn {
  ID
  CLIENT_ID
}

# A paginated list of JobboardSetting items.
type JobboardSettingPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of JobboardSetting items.
  data: [JobboardSetting!]!
}

type JobboardSetting {
  id: ID!
  client_id: String!
  custom_domain_enabled: Boolean!
  domain_mapping: String!
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `ClientDepartments`.
input ClientDepartmentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientDepartmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `ClientDepartments`.
enum ClientDepartmentsOrderByColumn {
  DEPARTMENT
  POSITION
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `ClientDepartments`.
input ClientDepartmentsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientDepartmentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientDepartmentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientDepartmentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `ClientDepartments`.
enum ClientDepartmentsWhereColumn {
  DEPARTMENT
  POSITION
  CLIENT_ID
}

# A paginated list of ClientDepartment items.
type ClientDepartmentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientDepartment items.
  data: [ClientDepartment!]!
}

type ClientDepartment {
  id: ID!
  client_id: String
  code: String
  no: Int
  department: String
  position: String
  parent_id: String
  clientDepartmentEmployees: [ClientDepartmentEmployee!]
  created_at: DateTime!
  updated_at: DateTime!
}

type ClientDepartmentEmployee {
  id: ID!
  client_id: String
  client_department_id: String
  clientEmployee: ClientEmployee
}

# Dynamic WHERE conditions for the `where` argument on the query `ClientDepartmentsAll`.
input ClientDepartmentsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientDepartmentsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientDepartmentsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientDepartmentsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `ClientDepartmentsAll`.
enum ClientDepartmentsAllWhereColumn {
  DEPARTMENT
  POSITION
  CLIENT_ID
}

# Order by clause for the `orderBy` argument on the query `allowances`.
input AllowancesOrderByOrderByClause {
  # The column that is used for ordering.
  field: AllowancesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `allowances`.
enum AllowancesOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `allowances`.
input AllowancesWhereWhereConditions {
  # The column that is used for the condition.
  column: AllowancesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AllowancesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AllowancesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `allowances`.
enum AllowancesWhereColumn {
  ID
  ALLOWANCE_GROUP_ID
}

type Allowance {
  id: ID!
  client_id: String!
  allowance_group_id: String!
  name: String!
  allowance_value: String!
  created_at: DateTime!
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `allowanceGroups`.
input AllowanceGroupsOrderByOrderByClause {
  # The column that is used for ordering.
  field: AllowanceGroupsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `allowanceGroups`.
enum AllowanceGroupsOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `allowanceGroups`.
input AllowanceGroupsWhereWhereConditions {
  # The column that is used for the condition.
  column: AllowanceGroupsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AllowanceGroupsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AllowanceGroupsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `allowanceGroups`.
enum AllowanceGroupsWhereColumn {
  ID
  CLIENT_ID
}

type AllowanceGroup {
  id: ID!
  client_id: String!
  department: String!
  name: String!
  position: String
  created_at: DateTime!
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `jobboardJobs`.
input JobboardJobsOrderByOrderByClause {
  # The column that is used for ordering.
  field: JobboardJobsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `jobboardJobs`.
enum JobboardJobsOrderByColumn {
  CREATED_AT
  TITLE
}

# Dynamic WHERE conditions for the `where` argument on the query `jobboardJobs`.
input JobboardJobsWhereWhereConditions {
  # The column that is used for the condition.
  column: JobboardJobsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [JobboardJobsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [JobboardJobsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `jobboardJobs`.
enum JobboardJobsWhereColumn {
  ID
  CLIENT_ID
  TITLE
  POSITION
  JOB_DETAILS
}

# A paginated list of JobboardJob items.
type JobboardJobPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of JobboardJob items.
  data: [JobboardJob!]!
}

type JobboardJob {
  id: ID!
  client_id: String!
  title: String
  welfare_regime: String
  position: String
  job_details: String
  job_requirements: String
  is_active: Boolean
  salary_range: String
  location: String
  expired_at: DateTime
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  jobboardApplicationCount: Int!
  assignedClientEmployees: [ClientEmployee]!
}

# Order by clause for the `orderBy` argument on the query `jobboardApplications`.
input JobboardApplicationsOrderByOrderByClause {
  # The column that is used for ordering.
  field: JobboardApplicationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `jobboardApplications`.
enum JobboardApplicationsOrderByColumn {
  CREATED_AT
  APPLIANT_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `jobboardApplications`.
input JobboardApplicationsWhereWhereConditions {
  # The column that is used for the condition.
  column: JobboardApplicationsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [JobboardApplicationsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [JobboardApplicationsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `jobboardApplications`.
enum JobboardApplicationsWhereColumn {
  ID
  CLIENT_ID
  JOBBOARD_JOB_ID
}

# A paginated list of JobboardApplication items.
type JobboardApplicationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of JobboardApplication items.
  data: [JobboardApplication!]!
}

type JobboardApplication {
  id: ID!
  client_id: String!
  jobboardJob: JobboardJob
  media: [Media]
  media_path: String
  appliant_name: String
  appliant_tel: String
  appliant_email: String
  cover_letter: String
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `evaluationGroups`.
input EvaluationGroupsOrderByOrderByClause {
  # The column that is used for ordering.
  field: EvaluationGroupsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `evaluationGroups`.
enum EvaluationGroupsOrderByColumn {
  CODE
  NAME
  STARTED_AT
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `evaluationGroups`.
input EvaluationGroupsWhereWhereConditions {
  # The column that is used for the condition.
  column: EvaluationGroupsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [EvaluationGroupsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [EvaluationGroupsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `evaluationGroups`.
enum EvaluationGroupsWhereColumn {
  ID
  CLIENT_ID
  STARTED_AT
  ENDED_AT
}

# A paginated list of EvaluationGroup items.
type EvaluationGroupPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of EvaluationGroup items.
  data: [EvaluationGroup!]!
}

type EvaluationGroup {
  id: ID!
  client_id: String!
  code: String!
  name: String!
  period: String!
  total_employee: Int!
  started_at: DateTime!
  ended_at: DateTime!
  configuration: String
  evaluationUsers: [EvaluationUser!]
}

type EvaluationUser {
  id: ID!
  client_id: String!
  evaluation_group_id: String!
  evaluator_id: String!
  client_employee_id: String!
  evaluation_id: String!
  scoreboard: String!
  score: Float!
  step_id: String!
  created_at: DateTime!
  updated_at: DateTime!
}

# Order by clause for the `orderBy` argument on the query `evaluations`.
input EvaluationsOrderByOrderByClause {
  # The column that is used for ordering.
  field: EvaluationsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `evaluations`.
enum EvaluationsOrderByColumn {
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `evaluations`.
input EvaluationsWhereWhereConditions {
  # The column that is used for the condition.
  column: EvaluationsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [EvaluationsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [EvaluationsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `evaluations`.
enum EvaluationsWhereColumn {
  ID
  CLIENT_ID
  EVALUATION_GROUP_ID
  EVALUATOR_LIST_ID
  CLIENT_EMPLOYEE_ID
}

# A paginated list of Evaluation items.
type EvaluationPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of Evaluation items.
  data: [Evaluation!]!
}

type Evaluation {
  id: ID!
  client_id: String!
  evaluation_group_id: String!
  client_employee_id: String!
  evaluator_list_id: String
  clientEmployee: ClientEmployee
  evaluationGroup: EvaluationGroup
  evaluationUsers: [EvaluationUser!]
}

# Dynamic WHERE conditions for the `where` argument on the query `allEvaluations`.
input AllEvaluationsWhereWhereConditions {
  # The column that is used for the condition.
  column: AllEvaluationsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AllEvaluationsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AllEvaluationsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `allEvaluations`.
enum AllEvaluationsWhereColumn {
  ID
  CLIENT_ID
  EVALUATION_GROUP_ID
}

# Dynamic WHERE conditions for the `where` argument on the query `evaluationUsers`.
input EvaluationUsersWhereWhereConditions {
  # The column that is used for the condition.
  column: EvaluationUsersWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [EvaluationUsersWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [EvaluationUsersWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `evaluationUsers`.
enum EvaluationUsersWhereColumn {
  ID
  CLIENT_ID
  EVALUATION_GROUP_ID
  EVALUATOR_ID
  EVALUATION_ID
}

# Order by clause for the `orderBy` argument on the query `clientCameraCheckinDevices`.
input ClientCameraCheckinDevicesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientCameraCheckinDevicesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientCameraCheckinDevices`.
enum ClientCameraCheckinDevicesOrderByColumn {
  NAME
  CLIENT_ID
  DEVICE_ID
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientCameraCheckinDevices`.
input ClientCameraCheckinDevicesWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientCameraCheckinDevicesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientCameraCheckinDevicesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientCameraCheckinDevicesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientCameraCheckinDevices`.
enum ClientCameraCheckinDevicesWhereColumn {
  NAME
  CLIENT_ID
  DEVICE_ID
}

# A paginated list of ClientCameraCheckinDevice items.
type ClientCameraCheckinDevicePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientCameraCheckinDevice items.
  data: [ClientCameraCheckinDevice!]!
}

type ClientCameraCheckinDevice {
  id: ID!
  client_id: String!
  name: String!
  device_id: String!
  token: String
  created_at: DateTime!
  updated_at: DateTime
}

# Dynamic WHERE conditions for the `where` argument on the query `hanetSettings`.
input HanetSettingsWhereWhereConditions {
  # The column that is used for the condition.
  column: HanetSettingsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [HanetSettingsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [HanetSettingsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `hanetSettings`.
enum HanetSettingsWhereColumn {
  ID
  CLIENT_ID
}

type HanetSetting {
  id: ID!
  client_id: String!
  token: String!
}

# Order by clause for the `orderBy` argument on the query `hanetDevices`.
input HanetDevicesOrderByOrderByClause {
  # The column that is used for ordering.
  field: HanetDevicesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `hanetDevices`.
enum HanetDevicesOrderByColumn {
  NAME
  CLIENT_ID
  DEVICE_ID
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `hanetDevices`.
input HanetDevicesWhereWhereConditions {
  # The column that is used for the condition.
  column: HanetDevicesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [HanetDevicesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [HanetDevicesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `hanetDevices`.
enum HanetDevicesWhereColumn {
  NAME
  CLIENT_ID
  DEVICE_ID
}

# A paginated list of HanetDevice items.
type HanetDevicePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of HanetDevice items.
  data: [HanetDevice!]!
}

type HanetDevice {
  id: ID!
  client_id: String!
  name: String!
  device_id: String!
  address: String
  place_name: String!
  created_at: DateTime!
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `hanetPlaces`.
input HanetPlacesOrderByOrderByClause {
  # The column that is used for ordering.
  field: HanetPlacesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `hanetPlaces`.
enum HanetPlacesOrderByColumn {
  NAME
  CLIENT_ID
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `hanetPlaces`.
input HanetPlacesWhereWhereConditions {
  # The column that is used for the condition.
  column: HanetPlacesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [HanetPlacesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [HanetPlacesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `hanetPlaces`.
enum HanetPlacesWhereColumn {
  NAME
  ADDRESS
  CLIENT_ID
}

# A paginated list of HanetPlace items.
type HanetPlacePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of HanetPlace items.
  data: [HanetPlace!]!
}

# Order by clause for the `orderBy` argument on the query `allHanetPlaces`.
input AllHanetPlacesOrderByOrderByClause {
  # The column that is used for ordering.
  field: AllHanetPlacesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `allHanetPlaces`.
enum AllHanetPlacesOrderByColumn {
  NAME
  CLIENT_ID
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `allHanetPlaces`.
input AllHanetPlacesWhereWhereConditions {
  # The column that is used for the condition.
  column: AllHanetPlacesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AllHanetPlacesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AllHanetPlacesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `allHanetPlaces`.
enum AllHanetPlacesWhereColumn {
  NAME
  ADDRESS
  CLIENT_ID
}

# Dynamic WHERE conditions for the `where` argument on the query `clientEmployeeDependents`.
input ClientEmployeeDependentsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientEmployeeDependentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientEmployeeDependentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientEmployeeDependentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientEmployeeDependents`.
enum ClientEmployeeDependentsWhereColumn {
  CLIENT_EMPLOYEE_ID
  TAX_CODE
}

# A paginated list of ClientEmployeeDependent items.
type ClientEmployeeDependentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientEmployeeDependent items.
  data: [ClientEmployeeDependent!]!
}

type ClientEmployeeDependent {
  id: ID!
  client_employee_id: String!
  name_dependents: String!
  tax_code: String
  relationship: String!
  from_date: String
  created_at: DateTime
  updated_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `clientDepartmentEmployees`.
input ClientDepartmentEmployeesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientDepartmentEmployeesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientDepartmentEmployees`.
enum ClientDepartmentEmployeesOrderByColumn {
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `clientDepartmentEmployees`.
input ClientDepartmentEmployeesWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientDepartmentEmployeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientDepartmentEmployeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientDepartmentEmployeesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientDepartmentEmployees`.
enum ClientDepartmentEmployeesWhereColumn {
  CLIENT_ID
  CLIENT_DEPARTMENT_ID
  CLIENT_EMPLOYEE_ID
}

# A paginated list of ClientDepartmentEmployee items.
type ClientDepartmentEmployeePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientDepartmentEmployee items.
  data: [ClientDepartmentEmployee!]!
}

# Order by clause for the `orderBy` argument on the query `workTimeRegisterPeriods`.
input WorkTimeRegisterPeriodsOrderByOrderByClause {
  # The column that is used for ordering.
  field: WorkTimeRegisterPeriodsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `workTimeRegisterPeriods`.
enum WorkTimeRegisterPeriodsOrderByColumn {
  WORKTIME_REGISTER_ID
  DATE_TIME_REGISTER
  TYPE_REGISTER
  START_TIME
  END_TIME
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `workTimeRegisterPeriods`.
input WorkTimeRegisterPeriodsWhereWhereConditions {
  # The column that is used for the condition.
  column: WorkTimeRegisterPeriodsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WorkTimeRegisterPeriodsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WorkTimeRegisterPeriodsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `workTimeRegisterPeriods`.
enum WorkTimeRegisterPeriodsWhereColumn {
  WORKTIME_REGISTER_ID
  DATE_TIME_REGISTER
  TYPE_REGISTER
}

# A paginated list of WorkTimeRegisterPeriod items.
type WorkTimeRegisterPeriodPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of WorkTimeRegisterPeriod items.
  data: [WorkTimeRegisterPeriod!]!
}

# Order by clause for the `orderBy` argument on the query `clientProjects`.
input ClientProjectsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientProjectsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientProjects`.
enum ClientProjectsOrderByColumn {
  CLIENT_ID
  LEADER_CLIENT_EMPLOYEE_ID
  STATUS
  START_TIME
  END_TIME
  CREATED_AT
  NAME
  CODE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientProjects`.
input ClientProjectsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientProjects`.
enum ClientProjectsWhereColumn {
  CLIENT_ID
  LEADER_CLIENT_EMPLOYEE_ID
  STATUS
  START_TIME
  END_TIME
  CREATED_AT
  NAME
  CODE
}

# Dynamic WHERE conditions for the `hasClientProjectEmployee` argument on the query `clientProjects`.
input ClientProjectsHasClientProjectEmployeeWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectsHasClientProjectEmployeeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectsHasClientProjectEmployeeWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectsHasClientProjectEmployeeWhereConditions!]
}

# Allowed column names for the `hasClientProjectEmployee` argument on the query `clientProjects`.
enum ClientProjectsHasClientProjectEmployeeColumn {
  CLIENT_EMPLOYEE_ID
}

# A paginated list of ClientProject items.
type ClientProjectPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientProject items.
  data: [ClientProject!]!
}

type ClientProject {
  id: ID!
  client_id: String!
  leader_client_employee_id: String
  code: String
  name: String
  status: String
  start_time: DateTime!
  end_time: DateTime!
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  ClientProjectEmployee: [ClientProjectEmployee]
}

type ClientProjectEmployee {
  id: ID!
  client_project_id: String!
  client_employee_id: String
  ClientEmployee: ClientEmployee
}

# Order by clause for the `orderBy` argument on the query `clientProjectsNotPaginate`.
input ClientProjectsNotPaginateOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientProjectsNotPaginateOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientProjectsNotPaginate`.
enum ClientProjectsNotPaginateOrderByColumn {
  CLIENT_ID
  LEADER_CLIENT_EMPLOYEE_ID
  STATUS
  START_TIME
  END_TIME
  CREATED_AT
  NAME
  CODE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientProjectsNotPaginate`.
input ClientProjectsNotPaginateWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectsNotPaginateWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectsNotPaginateWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectsNotPaginateWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientProjectsNotPaginate`.
enum ClientProjectsNotPaginateWhereColumn {
  CLIENT_ID
  LEADER_CLIENT_EMPLOYEE_ID
  STATUS
  START_TIME
  END_TIME
  CREATED_AT
  NAME
  CODE
}

# Dynamic WHERE conditions for the `hasClientProjectEmployee` argument on the query `clientProjectsNotPaginate`.
input ClientProjectsNotPaginateHasClientProjectEmployeeWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectsNotPaginateHasClientProjectEmployeeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectsNotPaginateHasClientProjectEmployeeWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectsNotPaginateHasClientProjectEmployeeWhereConditions!]
}

# Allowed column names for the `hasClientProjectEmployee` argument on the query `clientProjectsNotPaginate`.
enum ClientProjectsNotPaginateHasClientProjectEmployeeColumn {
  CLIENT_EMPLOYEE_ID
}

# Order by clause for the `orderBy` argument on the query `clientProjectEmployees`.
input ClientProjectEmployeesOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientProjectEmployeesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientProjectEmployees`.
enum ClientProjectEmployeesOrderByColumn {
  CLIENT_PROJECT_ID
  CLIENT_EMPLOYEE_ID
}

# Dynamic WHERE conditions for the `where` argument on the query `clientProjectEmployees`.
input ClientProjectEmployeesWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectEmployeesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectEmployeesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectEmployeesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientProjectEmployees`.
enum ClientProjectEmployeesWhereColumn {
  CLIENT_PROJECT_ID
  CLIENT_EMPLOYEE_ID
}

# A paginated list of ClientProjectEmployee items.
type ClientProjectEmployeePaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientProjectEmployee items.
  data: [ClientProjectEmployee!]!
}

# Order by clause for the `orderBy` argument on the query `clientProjectTimelogs`.
input ClientProjectTimelogsOrderByOrderByClause {
  # The column that is used for ordering.
  field: ClientProjectTimelogsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `clientProjectTimelogs`.
enum ClientProjectTimelogsOrderByColumn {
  CLIENT_PROJECT_ID
  CLIENT_EMPLOYEE_ID
  WORK_HOURS
  WORK_TYPE
  LOG_DATE
}

# Dynamic WHERE conditions for the `where` argument on the query `clientProjectTimelogs`.
input ClientProjectTimelogsWhereWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectTimelogsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectTimelogsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectTimelogsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `clientProjectTimelogs`.
enum ClientProjectTimelogsWhereColumn {
  CLIENT_PROJECT_ID
  CLIENT_EMPLOYEE_ID
  WORK_HOURS
  WORK_TYPE
  LOG_DATE
}

# Dynamic WHERE conditions for the `hasclientEmployee` argument on the query `clientProjectTimelogs`.
input ClientProjectTimelogsHasclientEmployeeWhereConditions {
  # The column that is used for the condition.
  column: ClientProjectTimelogsHasclientEmployeeColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [ClientProjectTimelogsHasclientEmployeeWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [ClientProjectTimelogsHasclientEmployeeWhereConditions!]
}

# Allowed column names for the `hasclientEmployee` argument on the query `clientProjectTimelogs`.
enum ClientProjectTimelogsHasclientEmployeeColumn {
  CODE
  FULL_NAME
}

# A paginated list of ClientProjectTimelog items.
type ClientProjectTimelogPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ClientProjectTimelog items.
  data: [ClientProjectTimelog!]!
}

type ClientProjectTimelog {
  id: ID!
  client_project_id: String!
  client_employee_id: String!
  work_hours: String!
  work_type: String!
  log_date: Date!
  work_description: String!
  created_at: DateTime
  updated_at: DateTime
  ClientEmployee: ClientEmployee
}

# Order by clause for the `orderBy` argument on the query `mobile_tiles`.
input MobileTilesOrderByOrderByClause {
  # The column that is used for ordering.
  field: MobileTilesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `mobile_tiles`.
enum MobileTilesOrderByColumn {
  ROW
  COL
}

type MobileTile {
  id: ID!
  row: Int
  col: Int
  tile_url: String
  use_webview: Boolean
  icon_url: String
  name: String
}

# Order by clause for the `orderBy` argument on the query `jobboardAssignments`.
input JobboardAssignmentsOrderByOrderByClause {
  # The column that is used for ordering.
  field: JobboardAssignmentsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `jobboardAssignments`.
enum JobboardAssignmentsOrderByColumn {
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `jobboardAssignments`.
input JobboardAssignmentsWhereWhereConditions {
  # The column that is used for the condition.
  column: JobboardAssignmentsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [JobboardAssignmentsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [JobboardAssignmentsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `jobboardAssignments`.
enum JobboardAssignmentsWhereColumn {
  JOBBOARD_JOB_ID
  CLIENT_EMPLOYEE_ID
  CLIENT_ID
  CREATED_AT
  UPDATED_AT
}

# A paginated list of JobboardAssignment items.
type JobboardAssignmentPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of JobboardAssignment items.
  data: [JobboardAssignment!]!
}

type JobboardAssignment {
  id: ID!
  client_id: ID!
  jobboard_job_id: ID!
  client_employee_id: ID!
  created_at: DateTime
  updated_at: DateTime
  clientEmployee: ClientEmployee!
}

# Dynamic WHERE conditions for the `where` argument on the query `paymentRequests`.
input PaymentRequestsWhereWhereConditions {
  # The column that is used for the condition.
  column: PaymentRequestsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PaymentRequestsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PaymentRequestsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `paymentRequests`.
enum PaymentRequestsWhereColumn {
  CLIENT_ID
  CLIENT_EMPLOYEE_ID
  STATE
}

# Order by clause for the `orderBy` argument on the query `paymentRequests`.
input PaymentRequestsOrderByOrderByClause {
  # The column that is used for ordering.
  field: PaymentRequestsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `paymentRequests`.
enum PaymentRequestsOrderByColumn {
  TITLE
  STATE
  CATEGORY
}

# A paginated list of PaymentRequest items.
type PaymentRequestPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of PaymentRequest items.
  data: [PaymentRequest!]!
}

type PaymentRequest {
  id: ID!
  client_id: String
  client_employee_id: String
  title: String
  note: String
  state: String
  category: String
  created_at: DateTime
  updated_at: DateTime
  clientEmployee: ClientEmployee
  attachments: [Attachment]
}

type Attachment {
  id: String
  name: String
  file_name: String
  collection_name: String
  mime_type: String
  created_at: String
  path: String
  url: String
  human_readable_size: String
}

# Order by clause for the `orderBy` argument on the query `paidLeaveChanges`.
input PaidLeaveChangesOrderByOrderByClause {
  # The column that is used for ordering.
  field: PaidLeaveChangesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `paidLeaveChanges`.
enum PaidLeaveChangesOrderByColumn {
  NAME
  FILE_NAME
}

# Dynamic WHERE conditions for the `where` argument on the query `paidLeaveChanges`.
input PaidLeaveChangesWhereWhereConditions {
  # The column that is used for the condition.
  column: PaidLeaveChangesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PaidLeaveChangesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PaidLeaveChangesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `paidLeaveChanges`.
enum PaidLeaveChangesWhereColumn {
  NAME
  FILE_NAME
  ID
  CLIENT_ID
}

# Order by clause for the `orderBy` argument on the query `paidLeaveChangesAll`.
input PaidLeaveChangesAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: PaidLeaveChangesAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `paidLeaveChangesAll`.
enum PaidLeaveChangesAllOrderByColumn {
  NAME
  FILE_NAME
  EFFECTIVE_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `paidLeaveChangesAll`.
input PaidLeaveChangesAllWhereWhereConditions {
  # The column that is used for the condition.
  column: PaidLeaveChangesAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [PaidLeaveChangesAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [PaidLeaveChangesAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `paidLeaveChangesAll`.
enum PaidLeaveChangesAllWhereColumn {
  NAME
  FILE_NAME
  ID
  CLIENT_ID
  CLIENT_EMPLOYEE_ID
}

type PaidLeaveChange {
  id: ID!
  client_id: String
  client_employee_id: String
  changed_ammount: String
  changed_reason: String
  effective_at: DateTime
  work_time_register_id: String
  month: String
  year: String
  clientEmployee: ClientEmployee
  changed_comment: String
}

# Order by clause for the `orderBy` argument on the query `socialSecurityClaimTrackings`.
input SocialSecurityClaimTrackingsOrderByOrderByClause {
  # The column that is used for ordering.
  field: SocialSecurityClaimTrackingsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `socialSecurityClaimTrackings`.
enum SocialSecurityClaimTrackingsOrderByColumn {
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `socialSecurityClaimTrackings`.
input SocialSecurityClaimTrackingsWhereWhereConditions {
  # The column that is used for the condition.
  column: SocialSecurityClaimTrackingsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SocialSecurityClaimTrackingsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SocialSecurityClaimTrackingsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `socialSecurityClaimTrackings`.
enum SocialSecurityClaimTrackingsWhereColumn {
  SOCIAL_SECURITY_CLAIM_ID
  CREATED_AT
  UPDATED_AT
}

# A paginated list of SocialSecurityClaimTracking items.
type SocialSecurityClaimTrackingPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of SocialSecurityClaimTracking items.
  data: [SocialSecurityClaimTracking!]!
}

type SocialSecurityClaimTracking {
  id: ID!
  social_security_claim_id: ID!
  content: String!
  created_at: String
  updated_at: String
}

# Order by clause for the `orderBy` argument on the query `socialSecurityClaimTrackingsAll`.
input SocialSecurityClaimTrackingsAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: SocialSecurityClaimTrackingsAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `socialSecurityClaimTrackingsAll`.
enum SocialSecurityClaimTrackingsAllOrderByColumn {
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `socialSecurityClaimTrackingsAll`.
input SocialSecurityClaimTrackingsAllWhereWhereConditions {
  # The column that is used for the condition.
  column: SocialSecurityClaimTrackingsAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [SocialSecurityClaimTrackingsAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [SocialSecurityClaimTrackingsAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `socialSecurityClaimTrackingsAll`.
enum SocialSecurityClaimTrackingsAllWhereColumn {
  SOCIAL_SECURITY_CLAIM_ID
  CREATED_AT
  UPDATED_AT
}

# Order by clause for the `orderBy` argument on the query `assignmentProjects`.
input AssignmentProjectsOrderByOrderByClause {
  # The column that is used for ordering.
  field: AssignmentProjectsOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `assignmentProjects`.
enum AssignmentProjectsOrderByColumn {
  CODE
  NAME
  CLIENT_ID
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `assignmentProjects`.
input AssignmentProjectsWhereWhereConditions {
  # The column that is used for the condition.
  column: AssignmentProjectsWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AssignmentProjectsWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AssignmentProjectsWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `assignmentProjects`.
enum AssignmentProjectsWhereColumn {
  CODE
  NAME
  CLIENT_ID
}

# A paginated list of AssignmentProject items.
type AssignmentProjectPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AssignmentProject items.
  data: [AssignmentProject!]!
}

type AssignmentProject {
  id: ID!
  code: String!
  name: String!
  client_id: String
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
}

# Order by clause for the `orderBy` argument on the query `assignmentTasks`.
input AssignmentTasksOrderByOrderByClause {
  # The column that is used for ordering.
  field: AssignmentTasksOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `assignmentTasks`.
enum AssignmentTasksOrderByColumn {
  CODE
  NAME
  ASSIGNMENT_PROJECT_ID
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `assignmentTasks`.
input AssignmentTasksWhereWhereConditions {
  # The column that is used for the condition.
  column: AssignmentTasksWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AssignmentTasksWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AssignmentTasksWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `assignmentTasks`.
enum AssignmentTasksWhereColumn {
  CODE
  NAME
  ASSIGNEE_USER_ID
  CREATOR_USER_ID
  ASSIGNMENT_PROJECT_ID
  STATUS
}

# A paginated list of AssignmentTask items.
type AssignmentTaskPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AssignmentTask items.
  data: [AssignmentTask!]!
}

type AssignmentTask {
  id: ID!
  code: String!
  name: String!
  assignment_project_id: String!
  creator_user_id: String
  assignee_user_id: String
  status: String!
  desc: String
  start_date: String
  end_date: String
  assignee: User
  created_at: DateTime
  updated_at: DateTime
  deleted_at: DateTime
  attachments: [Attachment]
}

# Order by clause for the `orderBy` argument on the query `assignmentTasksAll`.
input AssignmentTasksAllOrderByOrderByClause {
  # The column that is used for ordering.
  field: AssignmentTasksAllOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `assignmentTasksAll`.
enum AssignmentTasksAllOrderByColumn {
  CODE
  NAME
  START_DATE
  END_DATE
  ASSIGNMENT_PROJECT_ID
  CREATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `assignmentTasksAll`.
input AssignmentTasksAllWhereWhereConditions {
  # The column that is used for the condition.
  column: AssignmentTasksAllWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AssignmentTasksAllWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AssignmentTasksAllWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `assignmentTasksAll`.
enum AssignmentTasksAllWhereColumn {
  CODE
  NAME
  START_DATE
  END_DATE
  ASSIGNEE_USER_ID
  CREATOR_USER_ID
  ASSIGNMENT_PROJECT_ID
  STATUS
}

# Order by clause for the `orderBy` argument on the query `assignmentProjectUsers`.
input AssignmentProjectUsersOrderByOrderByClause {
  # The column that is used for ordering.
  field: AssignmentProjectUsersOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `assignmentProjectUsers`.
enum AssignmentProjectUsersOrderByColumn {
  ACCESS_LEVEL
  USER_ID
  ASSIGNMENT_PROJECT_ID
  INVITER_USER_ID
}

# Dynamic WHERE conditions for the `where` argument on the query `assignmentProjectUsers`.
input AssignmentProjectUsersWhereWhereConditions {
  # The column that is used for the condition.
  column: AssignmentProjectUsersWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AssignmentProjectUsersWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AssignmentProjectUsersWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `assignmentProjectUsers`.
enum AssignmentProjectUsersWhereColumn {
  ACCESS_LEVEL
  USER_ID
  ASSIGNMENT_PROJECT_ID
  INVITER_USER_ID
}

# A paginated list of AssignmentProjectUser items.
type AssignmentProjectUserPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AssignmentProjectUser items.
  data: [AssignmentProjectUser!]!
}

type AssignmentProjectUser {
  id: ID!
  assignment_project_id: String!
  user_id: String!
  user: User
  inviter_user_id: String
  access_level: String!
  created_at: DateTime
  updated_at: DateTime
}

# A paginated list of ProjectUser items.
type ProjectUserPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of ProjectUser items.
  data: [ProjectUser!]!
}

type ProjectUser {
  id: ID!
  name: String
}

# Order by clause for the `orderBy` argument on the query `appliedDocumentCategories`.
input AppliedDocumentCategoriesOrderByOrderByClause {
  # The column that is used for ordering.
  field: AppliedDocumentCategoriesOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `appliedDocumentCategories`.
enum AppliedDocumentCategoriesOrderByColumn {
  NAME
  CREATED_AT
  UPDATED_AT
}

# Dynamic WHERE conditions for the `where` argument on the query `appliedDocumentCategories`.
input AppliedDocumentCategoriesWhereWhereConditions {
  # The column that is used for the condition.
  column: AppliedDocumentCategoriesWhereColumn

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [AppliedDocumentCategoriesWhereWhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [AppliedDocumentCategoriesWhereWhereConditions!]
}

# Allowed column names for the `where` argument on the query `appliedDocumentCategories`.
enum AppliedDocumentCategoriesWhereColumn {
  NAME
  PARENT_ID
  CREATED_AT
  UPDATED_AT
}

# A paginated list of AppliedDocumentCategory items.
type AppliedDocumentCategoryPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of AppliedDocumentCategory items.
  data: [AppliedDocumentCategory!]!
}

# Order by clause for the `orderBy` argument on the query `listAppliedDocumentCategory`.
input ListAppliedDocumentCategoryOrderByOrderByClause {
  # The column that is used for ordering.
  field: ListAppliedDocumentCategoryOrderByColumn!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Allowed column names for the `orderBy` argument on the query `listAppliedDocumentCategory`.
enum ListAppliedDocumentCategoryOrderByColumn {
  PARENT_ID
}

type Mutation {
  createTimesheet(input: TimesheetInput): Timesheet
  updateTimesheet(id: ID!, input: TimesheetInput): Timesheet
  deleteTimesheet(id: ID!): Timesheet
  importTimesheet(client_id: String!, file: Upload!): String
  setTimesheet(input: TimesheetInput): Timesheet
  requestApproveTimesheet(id: String!, approved_by: String): Timesheet
  notifyRequestApproveTimesheet(id: String!, approved_by: String!): String
  confirmApproveTimesheet(
    id: String!
    state: String!
    reason: String
  ): Timesheet
  notifyConfirmApproveTimesheet(
    id: String!
    employee_id: String!
    status: String!
  ): String
  autoFillWorkingData(
    client_employee_id: ID!
    work_schedule_group_id: ID!
  ): String
  createClientEmployee(input: ClientEmployeeInput): ClientEmployee
  updateClientEmployee(id: ID!, input: ClientEmployeeInput): ClientEmployee
  updateClientEmployeeProfile(
    id: ID!
    input: ClientEmployeeProfileInput
  ): ClientEmployee
  updateClientEmployeeSalaryForm(
    id: ID!
    input: ClientEmployeeSalaryFormInput
  ): ClientEmployee
  deleteClientEmployee(id: ID!): ClientEmployee
  importClientEmployee(
    client_id: String!
    file: Upload!
    is_new: Boolean
  ): String
  sendApproveImportClientEmployee(
    client_id: String!
    file: Upload!
    is_new: Boolean
    reviewer_id: ID!
  ): String
  importPaidLeaveClientEmployee(client_id: String!, file: Upload!): String
  exportClientEmployee(client_id: String!): String
  exportForeignClientEmployee(
    client_id: String!
    from_date: String!
    to_date: String!
  ): String
  exportStatusClientEmployee(
    client_id: String!
    from_date: String!
    to_date: String!
  ): String
  updateClientEmployeeWorkScheduleGroupTemplateId(
    id: ID!
    work_schedule_group_template_id: String
  ): ClientEmployee
  resetPassword(id: ID, filter_code: ID, filter_client_id: ID): ClientEmployee
  exportClientEmployeeSummaryPdf(
    client_id: String
    date: String
    type: String
  ): String
  resetCustomerPassword(id: ID): ClientEmployee
  createClient(input: ClientInput): Client
  updateClient(id: ID!, lang: String, input: ClientInputUpdate): Client
  deleteClient(id: ID!): Client
  updateClientIsActive(id: ID!, is_active: Boolean!): Client
  importClient(file: Upload!): Client
  importSetupCalculationSheet(
    client_id: ID!
    template_name: String!
    file: Upload!
  ): String
  generatePayrollReport(
    from_date: String!
    to_date: String!
    filter_old: Int
    filter_position: String
  ): String
  generatePitReport(
    name: String!
    client_id: String!
    payrolls: [String]!
    variables: PitReportInput
  ): String
  generatePaidLeaveBalanceReport(client_id: String!, year: Int!): String
  deletePayrollReport(id: ID!): ReportPayroll
  deletePitReport(id: ID!): ReportPit
  createIglocalEmployee(input: IglocalEmployeeInput): IglocalEmployee
  updateIglocalEmployee(
    id: String
    input: IglocalEmployeeInput
  ): IglocalEmployee
  deleteIglocalEmployee(id: ID!): IglocalEmployee
  resetIglocalPassword(id: ID!): IglocalEmployee
  createIglocalAssignment(input: IglocalAssignmentInput): IglocalAssignment
  updateIglocalAssignment(
    id: String
    input: IglocalAssignmentInput
  ): IglocalAssignment
  deleteIglocalAssignment(id: ID!): IglocalAssignment
  createClientEmployeeOvertimeRequest(
    input: ClientEmployeeOvertimeRequestInput
  ): ClientEmployeeOvertimeRequest
  updateClientEmployeeOvertimeRequest(
    id: ID!
    input: ClientEmployeeOvertimeRequestInput
  ): ClientEmployeeOvertimeRequest
  deleteClientEmployeeOvertimeRequest(id: ID!): ClientEmployeeOvertimeRequest
  createClientEmployeeLeaveRequest(
    input: ClientEmployeeLeaveRequestInput
  ): ClientEmployeeLeaveRequest
  updateClientEmployeeLeaveRequest(
    id: ID!
    input: ClientEmployeeLeaveRequestUpdateInput
  ): ClientEmployeeLeaveRequest
  deleteClientEmployeeLeaveRequest(id: ID!): ClientEmployeeLeaveRequest
  createClientEmployeeEarlyLateRequest(
    input: ClientEmployeeEarlyLateRequestInput
  ): ClientEmployeeEarlyLateRequest
  updateClientEmployeeEarlyLateRequest(
    id: ID!
    input: ClientEmployeeEarlyLateRequestInput
  ): ClientEmployeeEarlyLateRequest
  deleteClientEmployeeEarlyLateRequest(id: ID!): ClientEmployeeEarlyLateRequest
  createCalculationSheet(input: CalculationSheetInput): CalculationSheet
  updateCalculationSheet(
    id: ID!
    input: CalculationSheetInputUpdate
  ): CalculationSheet
  deleteCalculationSheet(id: ID!): CalculationSheet
  updateCalculationSheetStatus(id: ID!, status: String!): CalculationSheet
  exportSalary(id: String!, variables: [String]!, forceExport: Boolean): String
  exportSalaryCSV(id: String!, variables: [String]!): String
  exportDebitNote(id: ID!, calculation_sheet_id: ID!): String
  exportAccountantReport(id: ID!, translates: [String]): JSON
  createCalculationSheetByNodejs(input: CalculationSheetNodeInput): String
  updatePayslipDate(id: ID!, payslip_date: Date): CalculationSheet
  createCalculationSheetClientEmployee(
    input: CalculationSheetClientEmployeeInput
  ): CalculationSheetClientEmployee
  updateCalculationSheetClientEmployee(
    id: ID
    filter_calculation_sheet_id: String
    filter_client_employee_id: String
    input: CalculationSheetClientEmployeeInput
  ): [CalculationSheetClientEmployee]
  deleteCalculationSheetClientEmployee(
    id: ID
    filter_calculation_sheet_id: String
    filter_client_employee_id: String
  ): [CalculationSheetClientEmployee]
  detailCalculationSheetClientEmployee(
    id: ID!
  ): DetailCalculationSheetClientEmployee
  listDetailCalculationSheetClientEmployees(
    calculation_sheet_id: String!
    employees: [String]
    perpage: Int
    page: Int
    orderby: String
    order: String
  ): ListCalculationSheetClientEmployee
  calculationSheetClientEmployeeByUserLogin(
    id: ID!
  ): calculationSheetClientEmployeeByUserLoginFields
  calculationSheetClientEmployeesByUserLogin(
    perpage: Int
    page: Int
    filter_name: String
    filter_month: Int
    filter_year: Int
    orderby: String
    order: String
  ): ListCalculationSheetClientEmployee
  exportPDFCalculationSheetClientEmployee(id: String!): String
  createCalculationSheetTemplate(
    input: CalculationSheetTemplateInput
  ): CalculationSheetTemplate
  updateCalculationSheetTemplate(
    id: ID!
    input: CalculationSheetTemplateInput
  ): CalculationSheetTemplate
  setCalculationSheetTemplateEnabled(
    id: ID!
    is_enabled: Boolean
  ): CalculationSheetTemplate
  deleteCalculationSheetTemplate(id: ID!): CalculationSheetTemplate
  createCalculationSheetVariable(
    input: CalculationSheetVariableInput
  ): CalculationSheetVariable
  updateCalculationSheetVariable(
    id: ID
    filter_calculation_sheet_id: String
    filter_client_employee_id: String
    filter_variable_name: String
    input: CalculationSheetVariableInput
  ): [CalculationSheetVariable]
  batchUpdateCalculationSheetVariable(
    calculation_sheet_id: String!
    client_employee_id: String!
    calculated_value: Float
    variables: [CalculationSheetBatchInput]
  ): String
  deleteCalculationSheetVariable(
    id: ID
    filter_calculation_sheet_id: String
    filter_client_employee_id: String
  ): [CalculationSheetVariable]
  createClientCustomVariable(
    input: ClientCustomVariableInput
  ): ClientCustomVariable
  updateClientCustomVariable(
    id: ID
    filter_client_id: String
    input: ClientCustomVariableInput
  ): [ClientCustomVariable]
  deleteClientCustomVariable(
    id: ID
    filter_client_id: String
  ): [ClientCustomVariable]
  createClientEmployeeCustomVariable(
    input: ClientEmployeeCustomVariableInput
  ): ClientEmployeeCustomVariable
  updateClientEmployeeCustomVariable(
    id: ID
    filter_client_employee_id: String
    input: ClientEmployeeCustomVariableInput
  ): [ClientEmployeeCustomVariable]
  deleteClientEmployeeCustomVariable(
    id: ID
    filter_client_employee_id: String
  ): [ClientEmployeeCustomVariable]
  makeVariableImportTemplate(
    client_id: String!
    variables: [ClientEmployeeCustomVariableTemplateExportInput]
    filename: String!
  ): String
  importClientEmployeeCustomVariables(
    client_id: String!
    file: Upload!
  ): ClientEmployeeCustomVariableImportResult
  createUser(input: UserInput): User
  updateUser(id: ID!, input: UserUpdateInput): User
  updateTimezone(id: ID!, timezone_name: String): User
  deleteUser(id: ID!): User
  changeRandomPassword(password: String!): User
  setPreference(id: ID!, prefered_language: PreferedLanguage!): User
  iglocalChangeRandomPassword(password: String!): User
  createSupportTicket(input: SupportTicketInput): SupportTicket
  updateSupportTicket(id: String, input: SupportTicketInput): SupportTicket
  deleteSupportTicket(id: ID!): SupportTicket
  createSupportTicketComment(
    input: SupportTicketCommentInput
  ): SupportTicketComment
  updateSupportTicketComment(
    id: String
    input: SupportTicketCommentInput
  ): SupportTicketComment
  deleteSupportTicketComment(id: ID!): SupportTicketComment
  createFormula(input: FormulaInput): Formula
  updateFormula(id: ID!, input: FormulaInput): Formula
  deleteFormula(id: ID!): Formula
  generateWorkSchedule(
    client_id: String!
    begin_date: Date!
    end_date: Date!
    work_days: String!
    check_in: String!
    check_out: String!
    rest_hours: String!
    work_schedule_group_id: String!
  ): [WorkSchedule]
  updateWorkSchedule(id: ID!, input: WorkScheduleInput): WorkSchedule
  deleteWorkSchedule(id: ID!): WorkSchedule
  createWorkScheduleGroup(input: WorkScheduleGroupInput!): WorkScheduleGroup
  updateWorkScheduleGroup(
    id: ID!
    input: WorkScheduleGroupInput!
  ): WorkScheduleGroup
  deleteWorkScheduleGroup(id: ID!): WorkScheduleGroup
  createWorkScheduleGroupTemplate(
    input: WorkScheduleGroupTemplateInput
  ): WorkScheduleGroupTemplate
  updateWorkScheduleGroupTemplate(
    id: ID!
    input: WorkScheduleGroupTemplateInput
  ): WorkScheduleGroupTemplate
  deleteWorkScheduleGroupTemplate(id: ID!): WorkScheduleGroupTemplate
  updateClientWorkflowSetting(
    id: ID!
    input: ClientWorkflowSettingInput
  ): ClientWorkflowSetting
  createApprove(input: ApproveInput): Approve
  updateApprove(id: ID!, input: ApproveInput): Approve
  acceptApprove(id: ID!, approved_at: DateTime): Approve
  deleteApprove(id: ID!): Approve
  createApproveFlowUser(
    approve_id: ID!
    reviewer_id: String
    status: String!
    next_step: Int
    comment: String
  ): String
  createApproveGroup(input: ApproveGroupInput): ApproveGroup
  applyApproveTimesheet(
    approve_id: ID!
    reviewer_id: String
    comment: String
    action: String!
    timesheets: [String]!
  ): Boolean
  createClientAssignment(input: ClientAssignmentInput): ClientAssignment
  deleteClientAssignment(id: ID!): ClientAssignment
  markReadNotifications(id: ID): String
  createKnowledgeQuestion(input: KnowledgeQuestionInput): KnowledgeQuestion
  updateKnowledgeQuestion(
    id: ID!
    input: KnowledgeQuestionInput
  ): KnowledgeQuestion
  deleteKnowledgeQuestion(id: ID!): KnowledgeQuestion
  uploadKnowledgeQuestion(file: Upload!): String
  createDebitNote(input: DebitNoteInput): DebitNote
  updateDebitNote(id: ID!, input: DebitNoteInput): DebitNote
  deleteDebitNote(id: ID!): DebitNote
  setPaidDebitNote(id: ID!): DebitNote
  createSocialSecurityProfile(
    input: SocialSecurityProfileInput
  ): SocialSecurityProfile
  createSocialSecurityProfiles(input: SocialSecurityProfilesInput): Boolean
  updateSocialSecurityProfile(
    id: ID!
    input: SocialSecurityProfileInputUpdate
  ): SocialSecurityProfile
  deleteSocialSecurityProfile(id: ID!): SocialSecurityProfile
  createTranslate(input: TranslationInput): Translation
  updateTranslate(id: ID!, input: TranslationInput): Translation
  deleteTranslate(id: ID!): String
  createCalculationSheetTemplateAssignment(
    input: CalculationSheetTemplateAssignmentInput
  ): CalculationSheetTemplateAssignment
  deleteCalculationSheetTemplateAssignment(
    id: ID!
  ): CalculationSheetTemplateAssignment
  createYearHoliday(input: YearHolidayInput): YearHoliday
  updateYearHoliday(id: ID!, input: YearHolidayInputUpdate): YearHoliday
  deleteYearHoliday(id: ID!): YearHoliday
  createCalculationSheetExportTemplate(
    input: CalculationSheetExportTemplateInput
  ): CalculationSheetExportTemplate
  updateCalculationSheetExportTemplate(
    id: ID!
    input: CalculationSheetExportTemplateInput
  ): CalculationSheetExportTemplate
  deleteCalculationSheetExportTemplate(id: ID!): CalculationSheetExportTemplate
  createSocialSecurityClaim(
    input: SocialSecurityClaimInput
  ): SocialSecurityClaim
  updateSocialSecurityClaim(
    id: ID!
    input: SocialSecurityClaimInput
  ): SocialSecurityClaim
  deleteSocialSecurityClaim(id: ID!): SocialSecurityClaim
  createApproveFlow(input: ApproveFlowInput): ApproveFlow
  setApproveFlowStep(id: String!, step: Int!): ApproveFlow
  removeApproveFlow(id: String!): ApproveFlow
  assignApproveFlowUser(approve_flow_id: String!, user_id: String!): Boolean
  unassignApproveFlowUser(approve_flow_id: String!, user_id: String!): Boolean
  createPayrollAccountantExportTemplate(
    input: PayrollAccountantExportTemplateInput
  ): PayrollAccountantExportTemplate
  updatePayrollAccountantExportTemplate(
    id: ID!
    input: PayrollAccountantExportTemplateInput
  ): PayrollAccountantExportTemplate
  deletePayrollAccountantExportTemplate(
    id: ID!
  ): PayrollAccountantExportTemplate
  createPayrollAccountantTemplate(
    input: PayrollAccountantTemplateInput
  ): PayrollAccountantTemplate
  updatePayrollAccountantTemplate(
    id: ID!
    input: PayrollAccountantTemplateInput
  ): PayrollAccountantTemplate
  deletePayrollAccountantTemplate(id: ID!): PayrollAccountantTemplate
  deleteClientLog(id: ID!): ClientLog
  clearAllClientLogs(client_id: ID!): String
  createClientEmployeeContract(
    input: ClientEmployeeContractInput
  ): ClientEmployeeContract
  deleteClientEmployeeContract(id: ID!): ClientEmployeeContract
  exportClientEmployeeContact(client_id: String!): String
  createEmailTemplate(input: EmailTemplateInput): EmailTemplate
  updateEmailTemplate(id: ID!, input: EmailTemplateInput): EmailTemplate
  deleteEmailTemplate(id: ID!): EmailTemplate
  createClientWifiCheckinSpot(
    input: ClientWifiCheckinSpotInput
  ): ClientWifiCheckinSpot
  updateClientWifiCheckinSpot(
    id: ID!
    input: ClientWifiCheckinSpotInput
  ): ClientWifiCheckinSpot
  deleteClientWifiCheckinSpot(id: ID!): ClientWifiCheckinSpot
  createTrainingSeminar(input: TrainingSeminarInput): TrainingSeminar
  updateTrainingSeminar(id: ID!, input: TrainingSeminarInput): TrainingSeminar
  deleteTrainingSeminar(id: ID!): TrainingSeminar
  createClientAppliedDocument(
    input: ClientAppliedDocumentInput
  ): ClientAppliedDocument
  updateClientAppliedDocument(
    id: ID!
    input: ClientAppliedDocumentInput
  ): ClientAppliedDocument
  updateClientAppliedDocumentStatus(
    id: ID!
    status: String!
  ): ClientAppliedDocument
  deleteClientAppliedDocument(id: ID!): ClientAppliedDocument
  createComment(input: CommentInput): Comment
  updateComment(id: ID!, input: CommentInput): Comment
  deleteComment(id: ID!): Comment
  uploadTemporaryMedia(file: Upload!): String
  attachMedia(
    id: ID!
    model: String!
    path: String!
    collection: String!
  ): Media
  detachMedia(
    id: ID!
    model: String!
    media_id: String
    media_ids: String
    collection: String!
  ): String
  createWorktimeRegister(input: WorktimeRegisterInput): WorktimeRegister
  updateWorktimeRegister(
    id: ID!
    input: WorktimeRegisterUpdateInput
  ): WorktimeRegister
  deleteWorktimeRegister(id: ID!): WorktimeRegister
  validateWorktimeRegister(input: WorktimeRegisterInput): Boolean
  validateWorktimeRegisterOvertime(input: WorktimeRegisterInput): Boolean
  createClientEmployeeTrainingSeminar(
    input: ClientEmployeeTrainingSeminarInput
  ): ClientEmployeeTrainingSeminar
  updateClientEmployeeTrainingSeminar(
    id: ID!
    input: ClientEmployeeTrainingSeminarInput
  ): ClientEmployeeTrainingSeminar
  deleteClientEmployeeTrainingSeminar(id: ID!): ClientEmployeeTrainingSeminar
  createContract(input: ContractInput): Contract
  updateContract(id: ID!, input: ContractInput): Contract
  deleteContract(id: ID!): Contract
  createContractTemplate(input: ContractTemplateInput): ContractTemplate
  updateContractTemplate(
    id: ID!
    input: ContractTemplateInput
  ): ContractTemplate
  deleteContractTemplate(id: ID!): ContractTemplate
  contractTemplateParseVariables(id: ID!): String
  contractTemplateParseImport(path: String!): String
  generateContract(contract_id: ID!, template_id: ID!): String!
  generateEmployeesContract(input: ContractTemplateEmployeeInput): String!
  generateEmployeesContractFromFile(
    input: ContractTemplateEmployeeInput
  ): String!
  createJobboardSetting(input: JobboardSettingInput): JobboardSetting
  updateJobboardSetting(id: ID!, input: JobboardSettingInput): JobboardSetting
  deleteJobboardSetting(id: ID!): JobboardSetting
  createClientDepartment(input: ClientDepartmentInput): ClientDepartment
  updateClientDepartment(
    id: ID!
    input: ClientDepartmentInput
  ): ClientDepartment
  deleteClientDepartment(id: ID!): String
  createAllowance(input: AllowanceInput): Allowance
  updateAllowance(id: ID!, input: AllowanceInput): Allowance
  deleteAllowance(id: ID!): Allowance
  deleteAllowanceByGroupId(allowance_group_id: String!): Allowance
  createAllowanceGroup(input: AllowanceGroupInput): AllowanceGroup
  updateAllowanceGroup(id: ID!, input: AllowanceGroupInput): AllowanceGroup
  deleteAllowanceGroup(id: ID!): AllowanceGroup
  setSetting(key: String!, value: String!): String!
  createJobboardJob(input: JobboardJobInput): JobboardJob
  updateJobboardJob(id: ID!, input: JobboardJobInput): JobboardJob
  deleteJobboardJob(id: ID!): JobboardJob
  getJobToken(client_id: ID!): String
  createJobboardApplication(
    input: JobboardApplicationInput
  ): JobboardApplication
  updateJobboardApplication(
    id: ID!
    input: JobboardApplicationInput
  ): JobboardApplication
  deleteJobboardApplication(id: ID!): JobboardApplication
  exportJobboardApplication(jobboard_job_id: ID!): String
  createEvaluationGroup(input: EvaluationGroupInput): EvaluationGroup
  updateEvaluationGroup(id: ID!, input: EvaluationGroupInput): EvaluationGroup
  deleteEvaluationGroup(client_id: ID!, evaluation_group_id: ID!): String
  createEvaluation(input: EvaluationInput): Evaluation
  updateEvaluation(id: ID!, input: EvaluationInput): Evaluation
  createEvaluationUser(input: EvaluationUserInput): EvaluationUser
  updateEvaluationUser(id: ID!, input: EvaluationUserInput): EvaluationUser
  createClientCameraCheckinDevice(
    input: ClientCameraCheckinDeviceInput
  ): ClientCameraCheckinDevice
  updateClientCameraCheckinDevice(
    id: ID!
    input: ClientCameraCheckinDeviceInput
  ): ClientCameraCheckinDevice
  deleteClientCameraCheckinDevice(id: ID!): ClientCameraCheckinDevice
  getAccessToken(client_id: ID!, code: String!): String
  createHanetDevice(input: HanetDeviceInput): HanetDevice
  updateHanetDevice(id: ID!, input: HanetDeviceInput): HanetDevice
  deleteHanetDevice(id: ID!): HanetDevice
  syncDevices(client_id: ID!): String
  createHanetPlace(input: HanetPlaceInput): String
  deleteHanetPlace(id: ID!): String
  syncHanetPlaces: String
  syncHanetPerson(client_id: ID!, id_list: [ID]!): String
  removeHanetPlacePerson(hanet_person_id: ID!, hanet_place_id: ID!): String
  jobboardUploadTemporaryMedia(file: Upload!, token: String!): String
  jobboardAttachMedia(
    id: ID!
    model: String!
    path: String!
    collection: String!
    token: String!
  ): Media
  jobboardDetachMedia(
    id: ID!
    model: String!
    media_id: String
    media_ids: String
    collection: String!
    token: String!
  ): String
  createClientEmployeeDependent(
    input: ClientEmployeeDependentInput
  ): ClientEmployeeDependent
  updateClientEmployeeDependent(
    id: ID!
    input: ClientEmployeeDependentInput
  ): ClientEmployeeDependent
  deleteClientEmployeeDependent(id: ID!): ClientEmployeeDependent
  createClientDepartmentEmployee(
    input: ClientDepartmentEmployeeInput
  ): ClientDepartmentEmployee
  deleteClientDepartmentEmployee(id: ID!): ClientDepartmentEmployee
  createWorkTimeRegisterPeriod(
    input: WorkTimeRegisterPeriodInput
  ): WorkTimeRegisterPeriod
  updateWorkTimeRegisterPeriod(
    id: ID!
    input: WorkTimeRegisterPeriodInput
  ): WorkTimeRegisterPeriod
  deleteWorkTimeRegisterPeriod(id: ID!): WorkTimeRegisterPeriod
  createClientProject(input: ClientProjectInput): ClientProject
  updateClientProject(id: ID!, input: ClientProjectInput): ClientProject
  deleteClientProject(id: ID!): ClientProject
  createClientProjectEmployee(
    input: ClientProjectEmployeeInput
  ): ClientProjectEmployee
  updateClientProjectEmployee(
    id: ID!
    input: ClientProjectEmployeeInput
  ): ClientProjectEmployee
  deleteClientProjectEmployee(id: ID!): ClientProjectEmployee
  createClientProjectTimelog(
    input: ClientProjectTimelogInput
  ): ClientProjectTimelog
  updateClientProjectTimelog(
    id: ID!
    input: ClientProjectTimelogInput
  ): ClientProjectTimelog
  deleteClientProjectTimelog(id: ID!): ClientProjectTimelog
  exportClientProjectTimelog(
    client_project_id: String!
    filter: String
    filterStartDate: String
    filterEndDate: String
    filterClientEmployeeId: String
  ): String
  createMobileTile(input: MobileTileInput!): MobileTile!
  updateMobileTile(id: ID!, input: MobileTileInput): MobileTile
  deleteMobileTile(id: ID!): MobileTile
  createJobboardAssignment(input: JobboardAssignmentInput): JobboardAssignment
  deleteJobboardAssignment(id: ID!): JobboardAssignment
  createPaymentRequest(input: PaymentRequestInput!): PaymentRequest
  updatePaymentRequest(
    id: ID!
    input: UpdatePaymentRequestInput!
  ): PaymentRequest
  deletePaymentRequest(id: ID!): PaymentRequest
  createPaidLeaveChange(input: PaidLeaveChangeInput): PaidLeaveChange
  updatePaidLeaveChange(id: ID!, input: PaidLeaveChangeInput): PaidLeaveChange
  deletePaidLeaveChange(id: ID!): PaidLeaveChange
  createSocialSecurityClaimTracking(
    input: SocialSecurityClaimTrackingInput
  ): SocialSecurityClaimTracking
  updateSocialSecurityClaimTracking(
    id: ID!
    input: SocialSecurityClaimTrackingInput
  ): SocialSecurityClaimTracking
  deleteSocialSecurityClaimTracking(id: ID!): SocialSecurityClaimTracking
  createAssignmentProject(input: AssignmentProjectInput): AssignmentProject
  updateAssignmentProject(
    id: ID!
    input: AssignmentProjectInput
  ): AssignmentProject
  deleteAssignmentProject(id: ID!): AssignmentProject
  createAssignmentTask(input: AssignmentTaskInput): AssignmentTask
  updateAssignmentTask(id: ID!, input: AssignmentTaskInput): AssignmentTask
  updateAssignmentTaskStatus(id: ID!, status: String): AssignmentTask
  updateAssignmentTaskAssignee(
    id: ID!
    assignee_user_id: String
  ): AssignmentTask
  updateAssignmentTaskStartEndDate(
    id: ID!
    start_date: String
    end_date: String
  ): AssignmentTask
  deleteAssignmentTask(id: ID!): AssignmentTask
  createAssignmentProjectUser(
    input: AssignmentProjectUserInput
  ): AssignmentProjectUser
  updateAssignmentProjectUser(
    id: ID!
    input: AssignmentProjectUserInput
  ): AssignmentProjectUser
  deleteAssignmentProjectUser(id: ID!): AssignmentProjectUser
  createAppliedDocumentCategory(
    input: AppliedDocumentCategoryInput
  ): AppliedDocumentCategory
  updateAppliedDocumentCategory(
    id: ID!
    input: AppliedDocumentCategoryInput
  ): AppliedDocumentCategory
  deleteAppliedDocumentCategory(id: ID!): AppliedDocumentCategory
  login(username: String!, password: String!, client_code: String): AuthPayload!
  refreshToken(input: RefreshTokenInput): AuthPayload!
  logout: LogoutResponse!
  forgotPassword(input: ForgotPasswordInput!): ForgotPasswordResponse!
  updateForgottenPassword(
    input: NewPasswordWithCodeInput!
  ): ForgotPasswordResponse!
  generate2faSecretCode: String!
  enable2fa(secretKey: String): String!
  get2faSecretKey: String!
  disable2fa(password: String!): String!
  otpLogin(secretKey: String!): String
}

input TimesheetInput {
  client_employee_id: String
  log_date: Date
  activity: String
  work_place: String
  working_hours: Float
  rest_hours: Float
  overtime_hours: Float
  check_in: String
  check_out: String
  leave_type: String
  attentdant_status: String
  work_status: String
  state: String
  reason: String
  approved_date: DateTime
  note: String
}

# Can be used as an argument to upload files using https://github.com/jaydenseric/graphql-multipart-request-spec
scalar Upload

input ClientEmployeeInput {
  client_id: String
  full_name: String
  code: String
  probation_start_date: Date
  probation_end_date: Date
  official_contract_signing_date: Date
  type_of_employment_contract: String
  salary: String
  allowance_for_responsibilities: String
  fixed_allowance: String
  is_tax_applicable: Boolean
  is_insurance_applicable: Boolean
  number_of_dependents: Int
  bank_account: String
  bank_account_number: String
  bank_name: String
  bank_branch: String
  social_insurance_number: String
  date_of_birth: String
  sex: String
  department: String
  position: String
  title: String
  workplace: String
  marital_status: String
  salary_for_social_insurance_payment: String
  effective_date_of_social_insurance: Date
  medical_care_hospital_name: String
  medical_care_hospital_code: String
  nationality: String
  nation: String
  id_card_number: String
  is_card_issue_date: Date
  id_card_issue_place: String
  birth_place_address: String
  birth_place_street: String
  birth_place_wards: String
  birth_place_district: String
  birth_place_city_province: String
  resident_address: String
  resident_street: String
  resident_wards: String
  resident_district: String
  resident_city_province: String
  contact_address: String
  contact_street: String
  contact_wards: String
  contact_district: String
  contact_city_province: String
  contact_phone_number: String
  contract_no: String
  household_head_info: String
  household_code: String
  household_head_fullname: String
  household_head_id_card_number: String
  household_head_relation: String
  household_head_phone: String
  resident_record_number: String
  resident_record_type: String
  resident_village: String
  resident_commune_ward_district_province: String
  foreigner_job_position: String
  foreigner_contract_status: String
  education_level: String
  status: String
  quitted_at: Date
  user_id: String
  role: String!
  work_schedule_group_template_id: String
  year_paid_leave_count: Float
  currency: String
  mst_code: String
  career: String
}

input ClientEmployeeProfileInput {
  marital_status: String
  contact_phone_number: String
  nationality: String
}

input ClientEmployeeSalaryFormInput {
  salary: String
  type_of_employment_contract: String
  probation_start_date: Date
  probation_end_date: Date
  official_contract_signing_date: Date
  workplace: String
  status: String
  quitted_at: Date
  allowance_for_responsibilities: String
  fixed_allowance: String
  is_tax_applicable: Boolean
  number_of_dependents: Int
  salary_for_social_insurance_payment: String
  contract_no: String
  currency: String
  mst_code: String
  social_insurance_number: String
  is_insurance_applicable: Boolean
  effective_date_of_social_insurance: Boolean
  medical_care_hospital_name: String
  medical_care_hospital_code: String
  household_code: String
  foreigner_job_position: String
  foreigner_contract_status: String
  year_paid_leave_count: Float
  custom_variables: [ClientEmployeeCustomVariableFormInput]
}

input ClientEmployeeCustomVariableFormInput {
  id: String
  readable_name: String!
  variable_name: String!
  variable_value: Float!
}

input ClientInput {
  code: String
  company_name: String
  address: String
  address_province: String
  address_city: String
  company_bank_account: String
  company_account_number: String
  company_bank_name: String
  company_bank_branch: String
  person_signing_a_bank_document: String
  employees_number_foreign: Int
  employees_number_vietnamese: Int
  rewards_for_achievements: String
  annual_salary_bonus: String
  social_insurance_and_health_insurance_ceiling: String
  unemployment_insurance_ceiling: String
  payroll_creator: String
  payroll_approver: String
  social_insurance_agency: String
  social_insurance_account_name: String
  social_insurance_account_number: String
  social_insurance_bank_name: String
  social_insurance_bank_branch: String
  social_insurance_unit_code: String
  trade_union_agency: String
  trade_union_account_name: String
  trade_union_account_number: String
  trade_union_bank_name: String
  trade_union_bank_branch: String
  presenter_phone: String
  company_contact_fax: String
  presenter_email: String
  presenter_name: String
  company_license_no: String
  company_license_issuer: String
  company_license_issued_at: Date
  company_license_updated_at: Date
  company_license_at: String
  timesheet_min_time_block: Int
  company_contact_phone: String
  company_contact_email: String
  day_payroll_start: Int
  day_payroll_end: Int
  type_of_business: String
  standard_work_hours_per_day: Float
}

input ClientInputUpdate {
  company_name: String
  address: String
  address_province: String
  address_city: String
  company_bank_account: String
  company_account_number: String
  company_bank_name: String
  company_bank_branch: String
  person_signing_a_bank_document: String
  employees_number_foreign: Int
  employees_number_vietnamese: Int
  rewards_for_achievements: String
  annual_salary_bonus: String
  social_insurance_and_health_insurance_ceiling: String
  unemployment_insurance_ceiling: String
  payroll_creator: String
  payroll_approver: String
  social_insurance_agency: String
  social_insurance_account_name: String
  social_insurance_account_number: String
  social_insurance_bank_name: String
  social_insurance_bank_branch: String
  social_insurance_unit_code: String
  trade_union_agency: String
  trade_union_account_name: String
  trade_union_account_number: String
  trade_union_bank_name: String
  trade_union_bank_branch: String
  presenter_phone: String
  company_contact_fax: String
  presenter_email: String
  presenter_name: String
  company_license_no: String
  company_license_issuer: String
  company_license_issued_at: Date
  company_license_updated_at: Date
  company_license_at: String
  timesheet_min_time_block: Int
  company_contact_phone: String
  company_contact_email: String
  day_payroll_start: Int
  day_payroll_end: Int
  type_of_business: String
  standard_work_hours_per_day: Float
}

input PitReportInput {
  tnct_luy_tien: String!
  tnch_khautru: String!
  so_nguoi_phuthuoc: String!
  giam_tru_giacanh_tungthang: String!
  bhbb_do_nld_tra: String!
  thu_nhap_tinhthue: String!
  pit_theo_bangluong_luytien: String!
  pit_theo_bangluong_khautru: String!
}

input IglocalEmployeeInput {
  user_id: String!
  code: String!
  name: String!
  role: String!
}

input IglocalAssignmentInput {
  iglocal_employee_id: String!
  client_id: String!
}

input ClientEmployeeOvertimeRequestInput {
  client_employee_id: String!
  start_time: DateTime!
  end_time: DateTime!
  hours_register: Float!
  type: String!
  reason: String
  descriptions: String!
  status: String!
  approved_by: String
  approved_date: DateTime
  approved_comment: String
}

input ClientEmployeeLeaveRequestInput {
  client_employee_id: String!
  start_time: DateTime!
  end_time: DateTime!
  duration: Float!
  half_day: String!
  type_of_leave: String!
  reason: String
  status: String!
}

input ClientEmployeeLeaveRequestUpdateInput {
  start_time: DateTime
  end_time: DateTime
  duration: Float
  half_day: String
  type_of_leave: String
  reason: String
  status: String
  approved_comment: String
}

input ClientEmployeeEarlyLateRequestInput {
  client_employee_id: String!
  start_time: DateTime!
  end_time: DateTime!
  duration: Float!
  type: String!
  reason: String
  status: String!
  approved_by: String
  approved_date: DateTime
  approved_comment: String
}

input CalculationSheetInput {
  client_id: String!
  name: String!
  fomulas: String!
  payment_period: String!
  display_columns: String!
  payslip_columns_setting: String
  payslip_accountant_columns_setting: String
  payslip_html_template_en: String
  payslip_html_template_vi: String
  payslip_html_template_ja: String
  is_multilingual: Boolean
  payslip_html_template: String
  template_export_id: String
  month: Int!
  year: Int!
  date_from: String!
  date_to: String!
  calculation_sheet_template_id: String
  status: String
  enable_notification_new_payroll: Int
  enable_show_payslip_for_employee: Int
}

input CalculationSheetInputUpdate {
  client_id: String
  name: String
  fomulas: String
  payment_period: String
  display_columns: String
  month: Int
  year: Int
  date_from: String
  date_to: String
  payslip_accountant_columns_setting: String
  status: String
  approved_comment: String
}

input CalculationSheetNodeInput {
  client_id: String!
  name: String!
  month: Int
  year: Int
  date_from: String
  date_to: String
  payroll_template: String
}

input CalculationSheetClientEmployeeInput {
  calculation_sheet_id: String!
  client_employee_id: String!
  calculated_value: Float!
  is_disabled: DateTime
}

type DetailCalculationSheetClientEmployee {
  id: ID!
  calculation_sheet: CalculationSheet
  client_employee: ClientEmployee
  calculated_value: Float!
  is_disabled: DateTime
  calculation_sheet_variable: [CalculationSheetVariable]
}

type ListCalculationSheetClientEmployee {
  data: [ListDetailCalculationSheetClientEmployee]
  pagination: CustomPagination
}

type ListDetailCalculationSheetClientEmployee {
  id: ID!
  calculationSheet: CalculationSheet
  clientEmployee: ClientEmployee
  calculated_value: Float!
  is_disabled: DateTime
  calculationSheetVariable: [CalculationSheetVariable]
}

type calculationSheetClientEmployeeByUserLoginFields {
  id: ID!
  calculation_sheet: CalculationSheet
  client_employee: ClientEmployee
  calculated_value: Float!
  is_disabled: DateTime
  calculationSheetVariable: [CalculationSheetVariable]
}

input CalculationSheetTemplateInput {
  client_id: String!
  name: String!
  fomulas: String!
  payment_period: String!
  display_columns: String!
  payslip_columns_setting: String
  payslip_accountant_columns_setting: String
  payslip_html_template_en: String
  payslip_html_template_vi: String
  payslip_html_template_ja: String
  is_multilingual: Boolean
  payslip_html_template: String
  enable_cross_ot_calculation: Boolean
  enable_show_payslip_for_employee: Boolean
  enable_notification_new_payroll: Boolean
  cross_ot_start_date: String
  cross_ot_end_date: String
  cross_ot_start_month: Int
  template_export_id: String
}

input CalculationSheetVariableInput {
  calculation_sheet_id: String!
  client_employee_id: String!
  readable_name: String!
  variable_name: String!
  variable_value: String
}

input CalculationSheetBatchInput {
  readable_name: String
  variable_name: String
  variable_value: String
}

input ClientCustomVariableInput {
  client_id: String!
  readable_name: String!
  variable_name: String!
  scope: String!
  variable_value: Float!
  sort_order: Int
}

input ClientEmployeeCustomVariableInput {
  client_employee_id: String!
  readable_name: String!
  variable_name: String!
  variable_value: Float!
}

input ClientEmployeeCustomVariableTemplateExportInput {
  readable_name: String
  variable_name: String
}

type ClientEmployeeCustomVariableImportResult {
  errors: [String]
}

input UserInput {
  client_id: String
  username: String!
  password: String
  is_internal: Int!
  name: String!
  email: String!
  timezone_name: String
}

input UserUpdateInput {
  username: String!
  password: String
  name: String!
  email: String!
  timezone_name: String
  is_email_notification: Boolean
  is_active: Boolean
}

enum PreferedLanguage {
  vi
  en
  ja
}

input SupportTicketInput {
  client_id: String!
  user_id: String!
  subject: String!
  category: String!
  priority: String!
  status: String!
  message: String!
  assigned: String
}

input SupportTicketCommentInput {
  support_ticket_id: String!
  user_comment_id: String!
  message: String
}

input FormulaInput {
  name: String
  func_name: String
  parameters: [String]
  formula: String
  description: String
}

input WorkScheduleInput {
  client_id: String
  schedule_date: Date
  check_in: String
  check_out: String
  rest_hours: String
  start_break: String
  end_break: String
  is_holiday: Boolean
  is_off_day: Boolean
}

input WorkScheduleGroupInput {
  work_schedule_group_template_id: String
  client_id: String!
  name: String
  timesheet_from: Date
  timesheet_to: Date
  rest_hours: String
  timesheet_deadline_at: DateTime
}

input WorkScheduleGroupTemplateInput {
  id: String
  client_id: String
  name: String
  check_in: String
  check_out: String
  start_break: String
  end_break: String
  rest_hours: String
  work_days: String
  is_default: Boolean
  timesheet_deadline_days: Int
  period_start_date: Int
  period_end_date: Int
  period_end_month: Int
}

input ClientWorkflowSettingInput {
  client_id: String
  enable_overtime_request: Boolean
  enable_leave_request: Boolean
  enable_early_leave_request: Boolean
  enable_timesheet_input: Boolean
  enable_timesheet_rule: Boolean
  enable_social_security_manage: Boolean
  enable_salary_payment: Boolean
  show_timesheet_for_customer: Boolean
  manage_user: String
  enable_wifi_checkin: Boolean
  enable_training_seminar: Boolean
  enable_recruit_function: Boolean
  enable_contract_reminder: Boolean
  enable_create_payroll: Boolean
  enable_setting_flow_permission: Boolean
  client_employee_limit: Int
}

input ApproveInput {
  type: String
  content: String
  assignee_id: String
  approved_at: DateTime
  step: Int
  target_type: String
  target_id: String
  approve_group_id: String
  original_creator_id: String
}

input ApproveGroupInput {
  client_id: ID!
  type: String!
  content: String
}

type ApproveGroup {
  id: String
  client_id: String
  type: String
  content: String
}

input ClientAssignmentInput {
  leader_id: String!
  staff_id: String!
  client_id: String!
}

input KnowledgeQuestionInput {
  question: String
  answer: String
  tags: String
  language: String
}

input DebitNoteInput {
  client_id: ID!
  batch_no: String!
  calculation_sheet_id: String!
  status: String
}

input SocialSecurityProfileInput {
  client_id: ID!
  client_employee_id: ID!
  salary_for_social_insurance_payment: String
  social_insurance_number_no: String
  comment: String
  tinh_trang: String
  tinh_trang_type: String
  tinh_trang_type_sub: String
  tinh_trang_from_date: String
  tinh_trang_to_date: String
  noi_dang_ki_kcb_ban_dau: String
  muc_luong_dieu_chinh: String
  chuc_vu_dieu_chinh: String
  tinh_trang_chung_tu_lien_quan: String
}

input SocialSecurityProfilesInput {
  client_id: ID!
  client_employee_ids: [ID]!
  comment: String
  tinh_trang: String
  tinh_trang_type: String
  tinh_trang_type_sub: String
  tinh_trang_from_date: String
  tinh_trang_to_date: String
  noi_dang_ki_kcb_ban_dau: String
  muc_luong_dieu_chinh: String
  chuc_vu_dieu_chinh: String
  tinh_trang_chung_tu_lien_quan: String
  attach_file: String
}

input SocialSecurityProfileInputUpdate {
  salary_for_social_insurance_payment: String
  social_insurance_number: String
  social_insurance_number_no: String
  comment: String
  status: String
  tinh_trang: String
  tinh_trang_type: String
  tinh_trang_type_sub: String
  tinh_trang_from_date: String
  tinh_trang_to_date: String
  noi_dang_ki_kcb_ban_dau: String
  muc_luong_dieu_chinh: String
  chuc_vu_dieu_chinh: String
  tinh_trang_chung_tu_lien_quan: String
  ngay_ke_khai_va_luu_tam_ho_so: String
  ngay_nop_ho_so: String
  so_ho_so_bhxh_da_ke_khai: String
  ngay_hen_tra_ket_qua: String
  tinh_trang_phia_khach_hang: String
}

input TranslationInput {
  language_id: String
  translatable_id: String
  translation: String
}

input CalculationSheetTemplateAssignmentInput {
  client_employee_id: String!
  template_id: String!
  client_id: String!
}

input YearHolidayInput {
  year: String!
  day: String!
}

input YearHolidayInputUpdate {
  year: String!
  day: String!
}

input CalculationSheetExportTemplateInput {
  client_id: String
  name: String
}

input SocialSecurityClaimInput {
  client_id: ID!
  client_employee_id: ID!
  state: String
  social_insurance_number: String!
  client_approved: Int
  claimed_amount: Int
  reason: String
  cd_claim_bao_hiem: String
  cd_claim_bao_hiem_sub: String
  cd_claim_bao_hiem_sub_sub: String
  cd_claim_bh_che_do_om_dau: String
  cd_claim_bh_om_dai_ngay: String
  cd_claim_bh_tu_ngay: String
  cd_claim_bh_den_ngay: String
  cd_claim_bh_tong_so_ngay_nghi: String
  cd_om_dau_ten_benh: String
  cd_om_dau_tuyen_benh_vien: String
  cd_om_dau_benh_dai_ngay: String
  cd_thai_san_ngay_sinh_con: String
  cd_thai_san_phau_thuat_thai_duoi_32t: String
  cd_thai_san_nghi_duong_thai: String
  cd_thai_san_ngay_nhan_con_nuoi: String
  cd_thai_san_tuoi_thai: String
  cd_thai_san_bien_phap_tranh_thai: String
  cd_thai_san_dieu_kien_sinh_con: String
  cd_thai_san_dieu_kien_khi_kham_thai: String
  cd_thai_san_cha_nghi_cham_con: String
  cd_thai_san_ngay_di_lam_thuc_te: String
  cd_thai_san_ngay_con_chet: String
  cd_thai_san_so_con_chet_khi_sinh: String
  cd_thai_san_ngay_me_chet: String
  cd_thai_san_ngay_ket_luan: String
  ds_ph_suc_khoe_ngay_tro_lai_lam_viec: String
  ds_ph_suc_khoe_ngay_dam_dinh: String
  tinh_trang_chung_tu_lien_quan: String
  ttgqhs_ngay_nop_ho_so: String
  ttgqhs_ngay_hen_tra_ket_qua: String
  ttgqhs_so_ho_so_bhxh_da_ke_khai: String
  ttgqhs_tong_so_ngay_duoc_tinh_huong_tro_cap: String
  ttgqhs_so_tien_duoc_huong: String
  ngay_ke_khai_va_luu_tam_ho_so: String
  ngay_tra_ket_qua: String
  bo_phan_cd_bhxh_date: String
  bo_phan_cd_bhxh_reviewer: String
  bo_phan_khtc_date: String
  bo_phan_khtc_reviewer: String
  bo_phan_tn_tkq_date: String
  bo_phan_tn_tkq_reviewer: String
  rejected_comment: String
  note: String
}

input ApproveFlowInput {
  client_id: String!
  flow_name: String!
  step: String!
}

input PayrollAccountantExportTemplateInput {
  client_id: String!
  name: String!
  template_variables: String!
}

input PayrollAccountantTemplateInput {
  client_id: String!
  loop_direction: String
  title: String
  group_type: String
  template_columns: JSON
}

input ClientEmployeeContractInput {
  client_employee_id: String!
  contract_type: String!
  contract_code: String
  contract_signing_date: String
  contract_end_date: String
}

input EmailTemplateInput {
  template_name: String
  content_en: String
  content_vi: String
  content_ja: String
  subject_en: String
  subject_vi: String
  subject_ja: String
}

input ClientWifiCheckinSpotInput {
  client_id: String!
  spot_name: String!
  spot_ssid: String!
  spot_mac: String!
  memo: String
}

input TrainingSeminarInput {
  client_id: String
  code: String
  name: String
  category_rank: String
  category_stage: String
  start_date: Date
  end_date: Date
  state: String
}

input ClientAppliedDocumentInput {
  client_id: String!
  document_type: String!
  status: String!
  user_id: String!
}

input CommentInput {
  user_id: String!
  message: String!
  target_type: String
  target_id: String
}

input WorktimeRegisterInput {
  client_employee_id: String!
  start_time: DateTime!
  end_time: DateTime!
  type: String!
  sub_type: String
  reason: String
  status: String!
  workTimeRegisterPeriod: CreateWorkTimeRegisterPeriodsHasMany
}

input CreateWorkTimeRegisterPeriodsHasMany {
  create: [WorkTimeRegisterPeriodInput!]!
}

input WorkTimeRegisterPeriodInput {
  worktime_register_id: String
  date_time_register: Date!
  type_register: Boolean
  start_time: String
  end_time: String
}

input WorktimeRegisterUpdateInput {
  start_time: DateTime
  end_time: DateTime
  sub_type: String
  reason: String
  status: String
  approved_comment: String
}

input ClientEmployeeTrainingSeminarInput {
  client_id: String
  client_employee_id: String
  training_seminar_id: String
  start_date: Date
  end_date: Date
  state: String!
}

input ContractInput {
  client_id: String
  name: String
  contract_type: String
  contract_variables: String
  contract_no: String
  note: String
}

input ContractTemplateInput {
  client_id: String
  name: String
  contract_type: String
  note: String
}

input ContractTemplateEmployeeInput {
  client_id: String
  contract_no: String
  contract_type: String
  contract_variables: String
  template_id: ID!
  employees: [String]
  note: String
  language: String
}

input JobboardSettingInput {
  client_id: String
  custom_domain_enabled: Boolean
  domain_mapping: String
}

input ClientDepartmentInput {
  client_id: String
  code: String
  department: String
  no: Int
  position: String
  parent_id: String
}

input AllowanceInput {
  client_id: String
  allowance_group_id: String
  name: String
  allowance_value: String
}

input AllowanceGroupInput {
  client_id: String
  name: String
  department: String
  position: String
}

input JobboardJobInput {
  client_id: String
  title: String
  welfare_regime: String
  position: String
  job_details: String
  job_requirements: String
  is_active: Boolean
  salary_range: String
  expired_at: DateTime
  location: String
}

input JobboardApplicationInput {
  client_id: String
  jobboard_job_id: String
  appliant_name: String
  appliant_tel: String
  appliant_email: String
  cover_letter: String
}

input EvaluationGroupInput {
  client_id: String
  code: String
  name: String
  period: String
  total_employee: Int
  started_at: DateTime
  ended_at: DateTime
  configuration: String
}

input EvaluationInput {
  client_id: String
  evaluation_group_id: String
  client_employee_id: String
  evaluator_list_id: String
}

input EvaluationUserInput {
  client_id: String
  evaluation_group_id: String
  evaluator_id: String
  client_employee_id: String
  evaluation_id: String
  step_id: String
  scoreboard: String
  score: Float!
}

input ClientCameraCheckinDeviceInput {
  client_id: String
  name: String
  device_id: String
  token: String
}

input HanetDeviceInput {
  client_id: String
  name: String
  device_id: String
  address: String
  place_name: String
}

input HanetPlaceInput {
  client_id: String
  name: String
  address: String
  hanet_place_id: Int
}

input ClientEmployeeDependentInput {
  client_employee_id: String!
  name_dependents: String!
  tax_code: String
  relationship: String!
  from_date: String
}

input ClientDepartmentEmployeeInput {
  client_id: String
  client_department_id: String
  client_employee_id: String
}

input ClientProjectInput {
  client_id: String
  leader_client_employee_id: String
  code: String
  name: String
  status: String
  start_time: DateTime!
  end_time: DateTime!
  created_at: DateTime
  updated_at: DateTime
}

input ClientProjectEmployeeInput {
  client_project_id: String
  client_employee_id: String
}

input ClientProjectTimelogInput {
  client_project_id: String
  client_employee_id: String
  work_hours: String!
  work_type: String!
  work_description: String!
  log_date: Date!
  created_at: DateTime
  updated_at: DateTime
}

input MobileTileInput {
  row: Int
  col: Int
  tile_url: String
  use_webview: Boolean
  icon_url: String
  name: String
}

input JobboardAssignmentInput {
  client_id: String!
  client_employee_id: String!
  jobboard_job_id: String!
}

input PaymentRequestInput {
  client_id: String
  client_employee_id: String
  title: String
  note: String
  state: String
  category: String
}

input UpdatePaymentRequestInput {
  state: String
}

input PaidLeaveChangeInput {
  client_id: String!
  client_employee_id: String!
  changed_ammount: Float!
  changed_comment: String
  changed_reason: String!
  effective_at: String!
  month: Int!
  year: Int!
}

input SocialSecurityClaimTrackingInput {
  social_security_claim_id: ID!
  content: String!
}

input AssignmentProjectInput {
  client_id: String
  code: String!
  name: String!
}

input AssignmentTaskInput {
  assignment_project_id: String
  creator_user_id: String
  assignee_user_id: String
  code: String!
  name: String!
  status: String!
  desc: String
  start_date: String
  end_date: String
}

input AssignmentProjectUserInput {
  assignment_project_id: String
  user_id: String
  inviter_user_id: String
  access_level: String
}

input AppliedDocumentCategoryInput {
  name: String!
  parent_id: String
}

type AuthPayload {
  access_token: String!
  refresh_token: String!
  expires_in: Int!
  token_type: String!
}

input RefreshTokenInput {
  refresh_token: String
}

type LogoutResponse {
  status: String!
  message: String
}

input ForgotPasswordInput {
  client_code: String!
  username: String!
}

type ForgotPasswordResponse {
  status: String!
  message: String
}

input NewPasswordWithCodeInput {
  email: String!
  token: String!
  username: String!
  client_code: String!
  password: String!
  password_confirmation: String!
}

type TimesheetPayload {
  status: String!
  message: String!
}

type TimesheetApproveEmployee {
  current_page: Int
  total: Int
  data: [ClientEmployee]
}

type ClientEmployeeSummaryPdf {
  id: ID
  full_name: String
  position: String
  department: String
  date_time_register: Date
  start_time: String
  end_time: String
  period_start_time: String
  period_end_time: String
  type_register: Int
  sub_type: String
  reason: String
  registered_hours: Float
  standard_work_hours_per_day: Float
}

type ClientPayload {
  status: String!
  message: String!
}

type ListCalculationSheetVariable {
  data: String
  pagination: CustomPagination
}

input DateRange {
  from: Date!
  to: Date!
}

input ApproveFlowUserInput {
  client_id: String!
  reviewer_id: String!
  flow_name: String!
  target_type: String!
  target_id: String!
  has_step: Boolean!
}

type Notification {
  id: String
  type: String
  notifiable_id: String
  notifiable_type: String
  data: String
  read_at: DateTime
  created_at: DateTime
  updated_at: DateTime
}

enum DebitNotesWhereColumn {
  CLIENT_ID
  STATUS
  CREATED_AT
}

type Setting {
  id: ID!
  key: String
  value: String
}

input HanetSettingInput {
  client_id: String
  token: String
}

type ImportResponse {
  ok: String
  error: String
  messages: [String]
}

type RefreshTokenPayload {
  access_token: String!
  refresh_token: String!
  expires_in: Int!
  token_type: String!
}

# Pagination information about the corresponding list of items.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String

  # Total number of node in connection.
  total: Int

  # Count of nodes in current request.
  count: Int

  # Current page of request.
  currentPage: Int

  # Last page in connection.
  lastPage: Int
}

# Allows ordering a list of records.
input OrderByClause {
  # The column that is used for ordering.
  field: String!

  # The direction that is used for ordering.
  order: SortOrder!
}

# Specify if you want to include or exclude trashed results from a query.
enum Trashed {
  # Only return trashed results.
  ONLY

  # Return both trashed and non-trashed results.
  WITH

  # Only return non-trashed results.
  WITHOUT
}

# Dynamic WHERE conditions for queries.
input WhereConditions {
  # The column that is used for the condition.
  column: String

  # The operator that is used for the condition.
  operator: SQLOperator = EQ

  # The value that is used for the condition.
  value: Mixed

  # A set of conditions that requires all conditions to match.
  AND: [WhereConditions!]

  # A set of conditions that requires at least one condition to match.
  OR: [WhereConditions!]
}
